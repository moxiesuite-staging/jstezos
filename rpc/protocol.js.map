{"version": 3, "mappings": "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", "sources": ["protocol.py"], "names": ["v", "pendulum", "pendulum.parse", "ParserError", "datetime", "v.timestamp", "RpcQuery", "head", "is_bh", "this.__getitem__", "this.__getitem__(head).calculate_hash", "min_date", "to_timestamp", "super.__call__", "length", "block_id", "slice", "block_id.start", "NotImplementedError", "BlockSliceQuery", "block_id.stop", "this.node", "this._wild_path", "this._params", "this.blocks", "super.__getitem__", "metadata", "this.head", "this.head.metadata", "this._caching", "this._parent", "this.header", "this.context", "this.context.contracts", "this.metadata", "pkh", "pkh.startswith", "this.manager_key", "this.manager_key().get", "pk", "this._parent[pkh].manager_key", "this._parent[pkh].manager_key().get", "ValueError", "count", "this.counter", "this().get", "this().get(\"script\", {}).get", "this._post", "query", "kwargs", "kwargs.update", "depth", "endorsement_operation", "item", "tuple", "is_ogh", "operation_hashes", "this._parent.operation_hashes", "enumerate", "validation_pass", "og_hash", "i", "j", "StopIteration", "find_index", "any", "map", "op", "list", "filter", "is_upvote", "this.votes", "is_ballot", "x", "contract_id", "is_it", "next", "is_origination", "this.managers", "data", "proposals", "proposal_id", "roll_count", "ProposalQuery", "res", "super.__repr__", "\"\\n\".join"], "sourcesContent": ["import pendulum\nfrom pendulum.parsing.exceptions import ParserError\nfrom datetime import datetime\nfrom itertools import count\nfrom typing import Iterator\n\nfrom pytezos.tools.docstring import get_attr_docstring\nfrom pytezos.rpc.search import BlockSliceQuery\nfrom pytezos.rpc.query import RpcQuery\nfrom pytezos.encoding import is_bh, is_ogh\n\n\ndef to_timestamp(v):\n    try:\n        v = pendulum.parse(v)\n    except ParserError:\n        pass\n    if isinstance(v, datetime):\n        v = int(v.timestamp())\n    return v\n\n\nclass BlocksQuery(RpcQuery, path='/chains/{}/blocks'):\n\n    def __call__(self, length=1, head=None, min_date=None):\n        \"\"\" Lists known heads of the blockchain sorted with decreasing fitness.\n        Optional arguments allows to returns the list of predecessors for known heads\n        or the list of predecessors for a given list of blocks.\n\n        :param length: The requested number of predecessors to returns (per requested head).\n        :param head: An empty argument requests blocks from the current heads. \\\n        A non empty list allow to request specific fragment of the chain.\n        :param min_date: When `min_date` is provided, heads with a timestamp before `min_date` are filtered out\n        :rtype: list[list[str]]\n        \"\"\"\n        if isinstance(head, str) and not is_bh(head):\n            head = self.__getitem__(head).calculate_hash()\n\n        if min_date and not isinstance(min_date, int):\n            min_date = to_timestamp(min_date)\n\n        return super(BlocksQuery, self).__call__(\n            length=length, head=head, min_date=min_date)\n\n    def __getitem__(self, block_id):\n        \"\"\" Construct block query or get a block range.\n\n        :param block_id: Block identity or block range\n\n          - int: Block level or offset from the head if negative;\n          - str: Block hash (base58) or special names (head, genesis), expressions like `head~1` etc;\n          - slice [:]: First value (start) must be int, second (stop) can be any Block ID or empty.\n        :rtype: BlockQuery or BlockSliceQuery\n        \"\"\"\n        if isinstance(block_id, slice):\n            if not isinstance(block_id.start, int):\n                raise NotImplementedError('Slice start should be an integer.')\n\n            return BlockSliceQuery(\n                start=block_id.start,\n                stop=block_id.stop,\n                node=self.node,\n                path=self._wild_path,\n                params=self._params\n            )\n\n        if isinstance(block_id, int) and block_id < 0:\n            return self.blocks[f'head~{block_id}']\n\n        return super(BlocksQuery, self).__getitem__(block_id)\n\n    @property\n    def current_voting_period(self):\n        \"\"\" Get block range for the current voting period.\n\n        :rtype: BlockSliceQuery\n        \"\"\"\n        metadata = self.head.metadata()\n        return BlockSliceQuery(\n            start=metadata['level']['level'] - metadata['level']['voting_period_position'],\n            stop='head',\n            node=self.node,\n            path=self._wild_path,\n            params=self._params\n        )\n\n    @property\n    def current_cycle(self):\n        \"\"\" Get block range for the current cycle.\n\n        :rtype: BlockSliceQuery\n        \"\"\"\n        metadata = self.head.metadata()\n        return BlockSliceQuery(\n            start=metadata['level']['level'] - metadata['level']['cycle_position'],\n            stop='head',\n            node=self.node,\n            path=self._wild_path,\n            params=self._params\n        )\n\n\nclass BlockQuery(RpcQuery, path='/chains/{}/blocks/{}'):\n\n    def __init__(self, yaargs, yakwargs):\n        JS(\"super(BlockQuery, self).__init__(*args, **kwargs)\")\n        self._caching = self._caching or 'head' not in self._params\n\n    @property\n    def predecessor(self):\n        \"\"\" Query previous block.\n\n        :rtype: BlockQuery\n        \"\"\"\n        return self._parent[self.header()['predecessor']]\n\n    @property\n    def baker(self):\n        \"\"\" Query block producer (baker).\n\n        :rtype: ContractQuery\n        \"\"\"\n        return self.context.contracts[self.metadata()['baker']]\n\n    def voting_period(self) -> int:\n        \"\"\" Get voting period for this block from metadata.\n        \"\"\"\n        return self.metadata()['level']['voting_period']\n\n    def level(self) -> int:\n        \"\"\" Get level for this block from metadata.\n        \"\"\"\n        return self.metadata()['level']['level']\n\n    def cycle(self) -> int:\n        \"\"\"\n        Get cycle for this block from metadata.\n        \"\"\"\n        return self.metadata()['level']['cycle']\n\n\nclass ContractQuery(RpcQuery, path='/chains/{}/blocks/{}/context/contracts/{}'):\n\n    def public_key(self) -> str:\n        \"\"\" Retrieve the contract manager's public key (base58 encoded)\n        \"\"\"\n        pkh = self._params[-1]\n        if pkh.startswith('KT'):\n            pkh = self.manager_key().get('manager')\n\n        pk = self._parent[pkh].manager_key().get('key')\n        if not pk:\n            raise ValueError('Public key is not revealed.')\n\n        return pk\n\n    def count(self) -> Iterator:\n        \"\"\" Get contract counter iterator: it returns incremented value on each call.\n        \"\"\"\n        return count(start=int(self.counter()) + 1, step=1)\n\n    def code(self):\n        \"\"\" Get contract code.\n\n        :returns: Micheline expression\n        \"\"\"\n        return self().get('script', {}).get('code')\n\n\nclass BigMapGetQuery(RpcQuery, path='/chains/{}/blocks/{}/context/contracts/{}/big_map_get'):\n\n    def post(self, query: dict):\n        \"\"\" Access the value associated with a key in the big map storage of the michelson.\n\n        :param query\n            {\n                key: { $key_type : <key> },\n                type: { \"prim\" : $key_prim }\n            }\n            $key_type: Provided key encoding, e.g. \"string\", \"bytes\" for hex-encoded string, \"int\"\n            key_prim: Expected high-level data type, e.g. \"address\", \"nat\", \"mutez\" (see storage section in code)\n        :returns: Micheline expression\n        \"\"\"\n        return self._post(json=query)\n\n\nclass ContextRawBytesQuery(RpcQuery, path='/chains/{}/blocks/{}/context/raw/bytes'):\n\n    def __init__(self, args, kwargs):\n        kwargs.update(timeout=60)\n        JS(\"super(ContextRawBytesQuery, self).__init__(*args, **kwargs)\")\n\n    def __call__(self, depth=1) -> dict:\n        \"\"\" Return the raw context.\n\n        :param depth: Context is a tree structure, default depth is 1\n        \"\"\"\n        return super(ContextRawBytesQuery, self).__call__(depth=depth)\n\n\nclass ContextRawJsonQuery(RpcQuery, path='/chains/{}/blocks/{}/context/raw/json'):\n\n    def __init__(self, args, kwargs):\n        kwargs.update(timeout=60)\n        JS(\"super(ContextRawJsonQuery, self).__init__(*args, **kwargs)\")\n\n\nclass ContextSeedQuery(RpcQuery, path='/chains/{}/blocks/{}/context/seed'):\n\n    def post(self):\n        \"\"\" Get seed of the cycle to which the block belongs.\n        \"\"\"\n        return self._post()\n\n\nclass EndorsingPower(RpcQuery, path='/chains/{}/blocks/{}/endorsing_power'):\n\n    def post(self, endorsement_operation):\n        \"\"\" Get the endorsing power of an endorsement operation, that is, the number of slots that the op has.\n\n        :param endorsement_operation\n            {\n                \"branch\": $block_hash,\n                \"contents\": [ $operation.alpha.contents ... ],\n                \"signature\": $Signature\n            }\n        \"\"\"\n        return self._post({'sendorsement_operation': endorsement_operation})\n\n\nclass OperationListListQuery(RpcQuery, path=['/chains/{}/blocks/{}/operations']):\n\n    def __getitem__(self, item):\n        \"\"\" Find operation by hash.\n\n        :param item: Operation group hash (base58)\n        :rtype: OperationQuery\n        \"\"\"\n        if isinstance(item, tuple):\n            return self[item[0]][item[1]]\n\n        if isinstance(item, str) and is_ogh(item):\n            operation_hashes = self._parent.operation_hashes()\n\n            def find_index():\n                for i, validation_pass in enumerate(operation_hashes):\n                    for j, og_hash in enumerate(validation_pass):\n                        if og_hash == item:\n                            return i, j\n                raise StopIteration('Operation group hash not found')\n\n            return self[find_index()]\n\n        return super(OperationListListQuery, self).__getitem__(item)\n\n    @property\n    def endorsements(self):\n        \"\"\" Operations with content of type: `endorsement`.\n\n        :rtype: OperationListQuery\n        \"\"\"\n        return self[0]\n\n    @property\n    def votes(self):\n        \"\"\" Operations with content of type: `proposal`, `ballot`.\n\n        :rtype: OperationListQuery\n        \"\"\"\n        return self[1]\n\n    @property\n    def anonymous(self):\n        \"\"\" Operations with content of type: `seed_nonce_revelation`, `double_endorsement_evidence`,\n            `double_baking_evidence`, `activate_account`.\n\n        :rtype: OperationListQuery\n        \"\"\"\n        return self[2]\n\n    @property\n    def managers(self):\n        \"\"\" Operations with content of type: `reveal`, `transaction`, `origination`, `delegation`.\n\n        :rtype: OperationListQuery\n        \"\"\"\n        return self[3]\n\n    def find_upvotes(self, proposal_id) -> list:\n        \"\"\" Find operations of kind `proposal` for given proposal.\n\n        :param proposal_id: Proposal hash (base58)\n        :returns: list of operation contents\n        \"\"\"\n        def is_upvote(op):\n            return any(map(\n                lambda x: x['kind'] == 'proposal' and proposal_id in x.get('proposals', []),\n                op['contents']))\n        return list(filter(is_upvote, self.votes()))\n\n    def find_ballots(self, proposal_id=None) -> list:\n        \"\"\" Find operations of kind `ballot`.\n\n        :param proposal_id: Proposal hash (optional)\n        :returns: list of operation contents\n        \"\"\"\n        def is_ballot(op):\n            return any(map(\n                lambda x: x['kind'] == 'ballot' and (proposal_id is None or proposal_id == x.get('proposal')),\n                op['contents']))\n        return list(filter(is_ballot, self.votes()))\n\n    def find_origination(self, contract_id):\n        \"\"\" Find origination of the contract.\n\n        :param contract_id: Contract ID (KT-address)\n        :returns: operation content\n        \"\"\"\n        def is_origination(op):\n            def is_it(x):\n                return x['kind'] == 'origination' \\\n                       and contract_id in x['metadata']['operation_result']['originated_contracts']\n            return any(map(is_it, op['contents']))\n        return next(filter(is_origination, self.managers()))\n\n\nclass OperationQuery(RpcQuery, path=['/chains/{}/blocks/{}/operations/{}/{}']):\n\n    def unsigned(self) -> dict:\n        \"\"\" Get operation group data without metadata and signature.\n        \"\"\"\n        data = self()\n        return {\n            'branch': data['branch'],\n            'contents': [\n                JS(\"{k: v for k, v in content.items() if k != 'metadata'}\")\n                for content in data['contents']\n            ]\n        }\n\n\nclass ProposalQuery(RpcQuery, path='/chains/{}/blocks/{}/votes/proposals/{}'):\n\n    def __call__(self) -> int:\n        \"\"\" Roll count for this proposal.\n        \"\"\"\n        proposals = self._parent()\n        proposal_id = self._params[-1]\n        roll_count = next(JS(\"(x[1] for x in proposals if x[0] == proposal_id)\"), 0)\n        return roll_count\n\n\nclass ProposalsQuery(RpcQuery, path='/chains/{}/blocks/{}/votes/proposals'):\n\n    def __getitem__(self, proposal_id) -> ProposalQuery:\n        \"\"\" Roll count for the selected proposal.\n\n        :param proposal_id: Base58-encoded proposal ID\n        :rtype: ProposalQuery\n        \"\"\"\n        return ProposalQuery(\n            path=self._wild_path + '/{}',\n            params=self._params + [proposal_id],\n            node=self.node\n        )\n\n    def __repr__(self):\n        res = [\n            super(ProposalsQuery, self).__repr__(),\n            f'[]{get_attr_docstring(self.__class__, \"__getitem__\")}',\n        ]\n        return '\\n'.join(res)\n\n\n__all__ = [\"BigMapGetQuery\", \"BlockQuery\", \"BlocksQuery\", \"ContextRawBytesQuery\", \"ContextRawJsonQuery\", \"ContextSeedQuery\", \"ContractQuery\", \"EndorsingPower\", \"OperationListListQuery\", \"OperationQuery\", \"ProposalQuery\", \"ProposalsQuery\", \"to_timestamp\"]\n"]}