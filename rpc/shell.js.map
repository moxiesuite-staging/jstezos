{"version": 3, "mappings": "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", "sources": ["shell.py"], "names": ["kwargs", "RpcQuery", "this.chains", "this.chains.main", "this.chains.main.blocks", "this.blocks", "this.blocks.head", "this.head", "this.head.hash", "CyclesQuery", "this.node", "this._wild_path", "this._params", "VotingPeriodsQuery", "this.head.context", "this.head.context.contracts", "this.chains.main.mempool", "block_time", "this.block", "this.block.context", "this.block.context.constants", "header", "this.head.header", "block_hash", "prev_block_dt", "datetime", "datetime.strptime", "elapsed_sec", "datetime.utcnow", "(datetime.utcnow() - prev_block_dt).seconds", "delay_sec", "sleep", "current_block_hash", "data", "this.chain_id", "hexlify", "base58_decode", "data.encode", "hexlify(base58_decode(data.encode())).decode", "this._delete", "this._post", "configuration", "operations_dict", "operations_dict.items", "operations", "operation", "dict", "item", "make_operation_result", "status", "list", "errors", "operation[1].pop1", "StopIteration", "res", "super.__repr__", "get_attr_docstring", "this.__class__", "\"\\n\".join", "super.__call__", "recurse", "_async", "force", "chain", "block", "bytes", "operation.hex", "protocol", "this._lines", "res.iter_lines", "json", "json.loads", "line", "line.decode", "ResponseGenerator", "this.node.request", "this.path", "wait", "this._get", "_filter", "monitor"], "sourcesContent": ["import requests\nimport simplejson as json\nfrom functools import lru_cache\nfrom binascii import hexlify\nfrom datetime import datetime\nfrom time import sleep\n\nfrom pytezos.encoding import base58_decode\nfrom pytezos.rpc.query import RpcQuery\nfrom pytezos.tools.docstring import get_attr_docstring\nfrom pytezos.rpc.search import CyclesQuery, VotingPeriodsQuery\n\n\ndef make_operation_result(**kwargs):\n    return {'metadata': {'operation_result': kwargs}}\n\n\nclass ShellQuery(RpcQuery, path=''):\n\n    @property\n    def blocks(self):\n        return self.chains.main.blocks\n\n    @property\n    def head(self):\n        return self.blocks.head\n\n    @property\n    @lru_cache(maxsize=None)\n    def block(self):\n        \"\"\"\n        Cached head block, useful if you just want to explore things.\n        \"\"\"\n        return self.blocks[self.head.hash()]\n\n    @property\n    def cycles(self):\n        \"\"\"\n        Operate on cycles rather than blocks.\n        \"\"\"\n        return CyclesQuery(\n            node=self.node,\n            path=self._wild_path + '/chains/{}/blocks',\n            params=self._params + ['main']\n        )\n\n    @property\n    def voting_periods(self):\n        \"\"\"\n        Operate on voting periods rather than blocks.\n        \"\"\"\n        return VotingPeriodsQuery(\n            node=self.node,\n            path=self._wild_path + '/chains/{}/blocks',\n            params=self._params + ['main']\n        )\n\n    @property\n    def contracts(self):\n        return self.head.context.contracts\n\n    @property\n    def mempool(self):\n        return self.chains.main.mempool\n\n    def wait_next_block(self, block_hash=None):\n        block_time = int(self.block.context.constants()[\"time_between_blocks\"][0])\n        header = self.head.header()\n        if block_hash is None:\n            block_hash = header['hash']\n\n        prev_block_dt = datetime.strptime(header['timestamp'], '%Y-%m-%dT%H:%M:%SZ')\n        elapsed_sec = (datetime.utcnow() - prev_block_dt).seconds\n        delay_sec = 0 if elapsed_sec > block_time else block_time - elapsed_sec\n        print(f'Wait {delay_sec} seconds until block {block_hash} is finalized')\n        sleep(delay_sec)\n\n        for i in range(block_time):\n            current_block_hash = self.head.hash()\n            if current_block_hash == block_hash:\n                sleep(1)\n            else:\n                return current_block_hash\n        assert False\n\n\nclass ChainQuery(RpcQuery, path='/chains/{}'):\n\n    def watermark(self):\n        \"\"\"\n        Chain watermark, hex encoded\n        \"\"\"\n        data = self.chain_id()\n        return hexlify(base58_decode(data.encode())).decode()\n\n\nclass InvalidBlockQuery(RpcQuery, path='/chains/{}/invalid_blocks/{}'):\n\n    def delete(self):\n        return self._delete()\n\n\nclass MempoolQuery(RpcQuery, path='/chains/{}/mempool'):\n\n    def post(self, configuration):\n        \"\"\"\n        Set operation filter rules.\n        :param configuration: a JSON dictionary, known keys are `minimal_fees`, `minimal_nanotez_per_gas_unit`,\n        `minimal_nanotez_per_byte`\n        \"\"\"\n        return self._post(json=configuration)\n\n\nclass PendingOperationsQuery(RpcQuery, path='/chains/{}/mempool/pending_operations'):\n\n    def __getitem__(self, item):\n        \"\"\"\n        Search for operation in node's mempool by hash.\n        :param item: operation group hash (base58)\n        \"\"\"\n        operations_dict = self()\n        for status, operations in operations_dict.items():\n            for operation in operations:\n                if isinstance(operation, dict):\n                    if operation['hash'] == item:\n                        return {**make_operation_result(status=status), **operation}\n                elif isinstance(operation, list):\n                    if operation[0] == item:\n                        errors = operation[1].pop1('error', default=[])\n                        return {**make_operation_result(status=status, errors=errors), **operation[1]}\n                else:\n                    assert False, operation\n        raise StopIteration\n\n    def __repr__(self):\n        res = [\n            super(PendingOperationsQuery, self).__repr__(),\n            '[]' + get_attr_docstring(self.__class__, '__getitem__')\n        ]\n        return '\\n'.join(res)\n\n\nclass DescribeQuery(RpcQuery, path='/describe'):\n\n    def __call__(self, recurse=True):\n        \"\"\"\n        Get RPCs documentation and input/output schema.\n        :param recurse: Show information for child elements, default is True.\n        In some cases doesn't work without this flag.\n        \"\"\"\n        return super(DescribeQuery, self).__call__(recurse=recurse)\n\n    def __repr__(self):\n        res = [\n            super(DescribeQuery, self).__repr__(),\n            f'(){get_attr_docstring(DescribeQuery, \"__call__\")}',\n            'Can be followed by any path:\\n.chains\\n.network.connections\\netc\\n'\n        ]\n        return '\\n'.join(res)\n\n\nclass BlockInjectionQuery(RpcQuery, path='/injection/block'):\n\n    def post(self, block, _async=False, force=False, chain=None):\n        \"\"\"\n        Inject a block in the node and broadcast it.\n        The `operations` embedded in `blockHeader` might be pre-validated using a contextual RPCs from the latest block\n        (e.g. '/blocks/head/context/preapply').\n        :param block: Json input:\n        {\n            \"data\": <hex-encoded block header>,\n            \"operations\": [ [ {\n                \"branch\": <block_hash>,\n                \"data\": <hex-encoded operation>\n            } ... ] ... ]\n        }\n        :param _async: By default, the RPC will wait for the block to be validated before answering,\n        set True if you don't want to.\n        :param force:\n        :param chain: Optionally you can specify the chain\n        :return: ID of the block\n        \"\"\"\n        return self._post(\n            params={\n                'async': _async,\n                'force': force,\n                'chain': chain\n            },\n            json=block\n        )\n\n\nclass OperationInjectionQuery(RpcQuery, path='/injection/operation'):\n\n    def post(self, operation, _async=False, chain=None):\n        \"\"\"\n        Inject an operation in node and broadcast it.\n        The `signedOperationContents` should be constructed using a contextual RPCs from the latest block\n        and signed by the client.\n        :param operation: Hex-encoded operation data or bytes\n        :param _async: By default, the RPC will wait for the operation to be (pre-)validated before answering,\n        set True if you don't want to.\n        :param chain: Optionally you can specify the chain\n        :return: ID of the operation\n        \"\"\"\n        if isinstance(operation, bytes):\n            operation = operation.hex()\n\n        return self._post(\n            params={\n                'async': _async,\n                'chain': chain\n            },\n            json=operation\n        )\n\n\nclass ProtocolInjectionQuery(RpcQuery, path='/injection/protocol'):\n\n    def post(self, protocol, _async=False, force=False):\n        \"\"\"\n        Inject a protocol in node.\n        :param protocol: Json input:\n        {\n            \"expected_env_version\": <integer>,\n            \"components\": [{\n                \"name\": <unistring>,\n                \"interface\"?: <hex-encoded data>,\n                \"implementation\": <hex-encoded data> }\n                 ...\n            ]}\n        }\n        :param _async:\n        :param force:\n        :return: ID of the protocol\n        \"\"\"\n        return self._post(\n            params={\n                'async': _async,\n                'force': force\n            },\n            json=protocol\n        )\n\n\nclass ResponseGenerator:\n\n    def __init__(self, res: requests.Response):\n        self._lines = res.iter_lines()\n\n    def __iter__(self):\n        for line in self._lines:\n            yield json.loads(line.decode())\n\n\nclass MonitorQuery(RpcQuery, path=['/monitor/active_chains',\n                                   '/monitor/bootstrapped',\n                                   '/monitor/commit_hash',\n                                   '/monitor/heads/{}',\n                                   '/monitor/protocols',\n                                   '/monitor/valid_blocks']):\n\n    def __call__(self, **kwargs):\n        return ResponseGenerator(self.node.request(\n            method='GET',\n            path=self.path,\n            params=kwargs,\n            stream=True\n        ))\n\n    def __repr__(self):\n        res = [\n            super(MonitorQuery, self).__repr__(),\n            'NOTE: Returned object is a generator.'\n        ]\n        return '\\n'.join(res)\n\n\nclass ConnectionQuery(RpcQuery, path='/network/connections/{}'):\n\n    def delete(self, wait=False):\n        return self._delete(params=dict(wait=wait))\n\n\nclass NetworkItems(RpcQuery, path=['/network/peers', '/network/points']):\n\n    def __call__(self, _filter=None):\n        return self._get(params={'filter': _filter})\n\n\nclass NetworkLogQuery(RpcQuery, path=['/network/peers/{}/log', '/network/points/{}/log']):\n\n    def __call__(self, monitor=False):\n        if monitor:\n            return ResponseGenerator(self.node.request(\n                method='GET',\n                path=self.path,\n                stream=True\n            ))\n        else:\n            return self._get()\n"]}