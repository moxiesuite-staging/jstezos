{"version": 3, "mappings": "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", "sources": ["big_map.py"], "names": ["args", "list", "args.length", "key_hash", "get_key_hash", "elt", "type_expr", "update", "big_map_id", "this.maps", "this.tmp_id", "this.alloc_id", "this.maybe_remove", "set", "this.maps.clear", "this.maybe_remove.clear", "assert_comparable", "k_type_expr", "assert_big_map_val", "v_type_expr", "res", "BigMap", "get_int", "val_expr", "big_map", "_", "network", "max", "kw", "this._check_allocated", "this.maybe_remove.add", "prim", "type_node", "val_node", "map", "make_elt", "this._pre_alloc", "copy", "this._pre_copy", "this._pre_remove", "parse_expression", "alloc_selector", "StackItem", "StackItem.parse", "alloc_id", "maybe_remove", "val", "val_node.get", "res.append", "maybe_remove.remove", "res.extend", "val_node[\"_diff\"].values", "storage", "storage.val_expr", "storage.type_expr", "diff_selector", "big_map_diff", "diff", "raw_map", "this.maps.get", "Map", "Map.empty", "key", "raw_map.make_key", "diff.get", "raw_map.make_val", "raw_map.update", "raw_map.remove", "key.val_expr", "key.type_expr", "big_map.val_expr", "Interop", "new Interop().using", "new Interop().using(network).shell", "new Interop().using(network).shell.head", "new Interop().using(network).shell.head.context", "new Interop().using(network).shell.head.context.big_maps", "JSONDecodeError", "big_map.find", "big_map.val_expr.get", "v_val_expr", "this._get_big_map_val", "big_map.type_expr", "this.maps[Number.parseInt(big_map)].find"], "sourcesContent": ["from typing import Dict\nfrom simplejson import JSONDecodeError\n\nfrom pytezos.interop import Interop\nfrom pytezos.repl.types import StackItem, Map, BigMap\nfrom pytezos.repl.parser import parse_expression, assert_expr_equal, get_int, assert_comparable, assert_big_map_val\nfrom pytezos.michelson.pack import get_key_hash\n\n\ndef make_elt(args):\n    assert isinstance(args, list) and len(args) == 2\n    return {'prim': 'Elt', 'args': args}\n\n\ndef elt_to_update(elt, type_expr, big_map_id):\n    key_hash = get_key_hash(elt['args'][0], type_expr['args'][0])\n    update = {'action': 'update',\n              'big_map': str(big_map_id),\n              'key_hash': key_hash,\n              'key': elt['args'][0],\n              'value': elt['args'][1]}\n    return key_hash, update\n\n\nclass BigMapPool:\n\n    def __init__(self):\n        self.maps = {}  # type: Dict[int, Map]\n        self.tmp_id = -1\n        self.alloc_id = 0\n        self.maybe_remove = set()\n\n    def reset(self):\n        self.maps.clear()\n        self.tmp_id = -1\n        self.alloc_id = 0\n        self.maybe_remove.clear()\n\n    def empty(self, k_type_expr, v_type_expr) -> BigMap:\n        assert_comparable(k_type_expr)\n        assert_big_map_val(v_type_expr)\n        res = BigMap(val=self.tmp_id,\n                     val_expr={'int': str(self.tmp_id), '_diff': {}},\n                     type_expr={'prim': 'big_map', 'args': [k_type_expr, v_type_expr]})\n        self.tmp_id -= 1\n        return res\n\n    def _pre_alloc(self, val_expr, type_expr):\n        res = {'int': str(self.tmp_id),\n               '_diff': JS(\"dict(elt_to_update(elt, type_expr, self.tmp_id) for elt in val_expr)\")}\n        self.tmp_id -= 1\n        return res\n\n    def _check_allocated(self, val_expr, type_expr, network=None):\n        big_map_id = get_int(val_expr)\n        assert big_map_id >= 0, f'expected an allocated big map (>=0), got {big_map_id}'\n        if big_map_id in self.maps:\n            big_map = self.maps[big_map_id]\n            _ = [assert_expr_equal(type_expr['args'][i], big_map.type_expr['args'][i]) for i in [0, 1]]\n            return big_map_id, {'_diff': {}}\n        else:\n            assert network, f'big map #{big_map_id} is not allocated'\n            self.alloc_id = max(self.alloc_id, big_map_id + 1)\n            return big_map_id, {'_diff': {}, '_network': network}\n\n    def _pre_copy(self, val_expr, type_expr, network=None):\n        big_map_id, kw = self._check_allocated(val_expr, type_expr, network)\n        res = {'int': str(self.tmp_id), '_copy': big_map_id, **kw}\n        self.tmp_id -= 1\n        return res\n\n    def _pre_remove(self, val_expr, type_expr, network=None):\n        big_map_id, kw = self._check_allocated(val_expr, type_expr, network)\n        self.maybe_remove.add(big_map_id)\n        return {'int': str(big_map_id), **kw}\n\n    def pre_alloc(self, val_expr, type_expr, copy=False, network=None):\n        def alloc_selector(val_node, type_node, res, type_path):\n            prim = type_node['prim']\n            if prim in ['list', 'set']:\n                return res\n            if prim in ['pair', 'or']:\n                return {'prim': val_node['prim'], 'args': res}\n            elif prim == 'option' and val_node['prim'] == 'Some':\n                return {'prim': val_node['prim'], 'args': res}\n            elif prim == 'map':\n                return list(map(make_elt, res))\n            elif prim == 'big_map':\n                if isinstance(val_node, list):\n                    return self._pre_alloc(val_node, type_node)\n                elif copy:\n                    return self._pre_copy(val_node, type_node, network=network)\n                else:\n                    return self._pre_remove(val_node, type_node, network=network)\n\n            return val_node\n\n        val_expr = parse_expression(val_expr, type_expr, alloc_selector)\n        return StackItem.parse(val_expr=val_expr, type_expr=type_expr)\n\n    def diff(self, storage: StackItem):\n        res = []\n        alloc_id = self.alloc_id\n        maybe_remove = self.maybe_remove\n\n        def diff_selector(val_node, type_node, val, type_path):\n            JS(\"nonlocal res, alloc_id, maybe_remove\")\n            prim = type_node['prim']\n            if prim in ['list', 'set']:\n                return val\n            if prim in ['pair', 'or']:\n                return {'prim': val_node['prim'], 'args': val}\n            elif prim == 'option' and val_node['prim'] == 'Some':\n                return {'prim': val_node['prim'], 'args': val}\n            elif prim == 'map':\n                return list(map(make_elt, val))\n            elif prim == 'big_map':\n                assert isinstance(val, int), f'expected big map pointer'\n                if val < 0:\n                    big_map_id = alloc_id\n                    if val_node.get('_copy'):\n                        res.append({'action': 'copy',\n                                    'source_big_map': str(val_node['_copy']),\n                                    'destination_big_map': str(big_map_id)})\n                    else:\n                        res.append({'action': 'alloc',\n                                    'big_map': str(big_map_id),\n                                    'key_type': type_node['args'][0],\n                                    'value_type': type_node['args'][1]})\n                    alloc_id += 1\n                else:\n                    big_map_id = val\n                    maybe_remove.remove(big_map_id)\n\n                res.extend(map(lambda x: {**x, 'big_map': str(big_map_id)}, val_node['_diff'].values()))\n                return {'int': str(big_map_id)}\n            else:\n                return val_node\n\n        val_expr = parse_expression(storage.val_expr, storage.type_expr, diff_selector)\n        res.extend([{'action': 'remove', 'big_map': x} for x in maybe_remove])\n        return StackItem.parse(val_expr, storage.type_expr), res\n\n    def commit(self, big_map_diff: list):\n        for diff in big_map_diff:\n            big_map_id = int(diff['big_map'])\n            raw_map = self.maps.get(big_map_id)\n            if diff['action'] == 'alloc':\n                assert raw_map is None, f'#{big_map_id} already allocated'\n                self.maps[big_map_id] = Map.empty(k_type_expr=diff['key_type'], v_type_expr=diff['value_type'])\n            elif diff['action'] == 'remove':\n                assert raw_map is not None, f'#{big_map_id} is not allocated'\n                del self.maps[big_map_id]\n            elif diff['action'] == 'update':\n                assert raw_map is not None, f'#{big_map_id} is not allocated'\n                key = raw_map.make_key(diff['key'])\n                if diff.get('value'):\n                    val = raw_map.make_val(diff['value'])\n                    self.maps[big_map_id] = raw_map.update(key, val)\n                else:\n                    self.maps[big_map_id] = raw_map.remove(key)\n\n        if big_map_diff:\n            self.alloc_id = max([int(x['big_map']) for x in big_map_diff]) + 1\n        self.maybe_remove.clear()\n\n    def _get_big_map_val(self, big_map: BigMap, key: StackItem):\n        key_hash = get_key_hash(key.val_expr, key.type_expr)\n        network = big_map.val_expr['_network']\n        try:\n            res = Interop().using(network).shell.head.context.big_maps[int(big_map)][key_hash]()\n        except JSONDecodeError:\n            res = None\n        return res\n\n    def contains(self, big_map: BigMap, key: StackItem) -> bool:\n        if key in big_map:\n            return big_map.find(key) is not None\n        if int(big_map) >= 0:\n            if big_map.val_expr.get('_network'):\n                v_val_expr = self._get_big_map_val(big_map, key)\n                return v_val_expr is not None\n            else:\n                assert int(big_map) in self.maps, f'#{int(big_map)} is not allocated'\n                return key in self.maps[int(big_map)]\n        return False\n\n    def find(self, big_map: BigMap, key: StackItem) -> 'StackItem':\n        if key in big_map:\n            return big_map.find(key)\n        if int(big_map) >= 0:\n            if big_map.val_expr.get('_network'):\n                v_val_expr = self._get_big_map_val(big_map, key)\n                if v_val_expr:\n                    return StackItem.parse(val_expr=v_val_expr, type_expr=big_map.type_expr['args'][1])\n            else:\n                assert int(big_map) in self.maps, f'#{int(big_map)} is not allocated'\n                return self.maps[int(big_map)].find(key)\n\n\n__all__ = [\"BigMapPool\", \"elt_to_update\", \"make_elt\"]\n"]}