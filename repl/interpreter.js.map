{"version": 3, "mappings": "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", "sources": ["interpreter.py"], "names": ["content", "obj", "obj.get", "format_content", "row", "item", "Operation", "yaml", "yaml.dump", "get_content", "item.val_expr", "yaml.dump(get_content(item.val_expr)).rstrip", "List", "item.val_type", "yaml.dump(function () {\n    var _pj_a = [], _pj_b = item.val_expr;\n    for (var _pj_c = 0, _pj_d = _pj_b.length; (_pj_c < _pj_d); _pj_c += 1) {\n        var x = _pj_b[_pj_c];\n        _pj_a.push(get_content(x));\n    }\n    return _pj_a;\n}\n.call(this)).rstrip", "micheline_to_michelson", "item.type_expr", "item.name", "diff", "diff.get", "res", "content.get", "newline", "depth", "res.append", "items", "break_line", "res.extend", "\"\".join", "\"\".join(res).strip", "all", "map", "result", "kind", "list", "format_diff", "format_stack_item", "operations", "storage", "big_map_diff", "ename", "error", "Object.getPrototypeOf(error).__name__", "MichelsonRuntimeError", "evalue", "traceback", "error.message", "\" -> \".join", "error.trace", "MichelsonParserError", "pformat", "error.args", "this.ctx", "Context", "this.parser", "MichelsonParser", "helpers_prim", "this.debug", "debug", "int_res", "code_expr", "michelson_to_micheline", "code", "e", "format_stderr", "backup", "deepcopy", "do_interpret", "this.ctx.pushed", "this.ctx.dump", "format_result", "format_stdout", "this.ctx.stdout", "this.ctx.reset", "int_res.get"], "sourcesContent": ["import yaml\nfrom copy import deepcopy\nfrom pprint import pformat\n\nfrom pytezos.michelson.grammar import MichelsonParser, MichelsonParserError\nfrom pytezos.michelson.converter import michelson_to_micheline, micheline_to_michelson\nfrom pytezos.repl.control import do_interpret, MichelsonRuntimeError\nfrom pytezos.repl.helpers import *\nfrom pytezos.repl.arithmetic import *\nfrom pytezos.repl.structures import *\nfrom pytezos.repl.blockchain import *\n\n\ndef get_content(obj: dict):\n    content = obj.get('_content')\n    if content:\n        return format_content(content)\n    return {}\n\n\ndef format_stack_item(item: StackItem):\n    row = {}\n    if isinstance(item, Operation):\n        row['value'] = yaml.dump(get_content(item.val_expr)).rstrip('\\n')\n    elif isinstance(item, List) and item.val_type() == Operation:\n        row['value'] = yaml.dump([get_content(x) for x in item.val_expr]).rstrip('\\n')\n    else:\n        row['value'] = micheline_to_michelson(item.val_expr)\n\n    row['type'] = micheline_to_michelson(item.type_expr)\n    if item.name is not None:\n        row['name'] = f'@{item.name}'\n\n    return row\n\n\ndef format_diff(diff: dict):\n    if diff['action'] == 'alloc':\n        return {'big_map': diff['big_map'],\n                'action': diff['action'],\n                'key': micheline_to_michelson(diff['key_type']),\n                'value': micheline_to_michelson(diff['value_type'])}\n    elif diff['action'] == 'update':\n        return {'big_map': diff['big_map'],\n                'action': diff['action'],\n                'key': micheline_to_michelson(diff['key']),\n                'value': micheline_to_michelson(diff['value']) if diff.get('value') else 'null'}\n    elif diff['action'] == 'copy':\n        return {'destination_big_map': diff['big_map'],\n                'action': diff['action'],\n                'value': diff['source_big_map']}\n    elif diff['action'] == 'remove':\n        return {'big_map': diff['big_map'],\n                'action': diff['action']}\n    else:\n        assert False, diff['action']\n\n\ndef format_content(content):\n    if content['kind'] == 'transaction':\n        return {'kind': content['kind'],\n                'target': content['destination'],\n                'amount': content['amount'],\n                'entrypoint': content['parameters']['entrypoint'],\n                'parameters': micheline_to_michelson(content['parameters']['value'])}\n    elif content['kind'] == 'origination':\n        res = {'kind': content['kind'],\n               'target': content['originated_contract'],\n               'amount': content['balance'],\n               'storage': micheline_to_michelson(content['script']['storage']),\n               'code': micheline_to_michelson(content['script']['code'])}\n        if content.get('delegate'):\n            res['delegate'] = content['delegate']\n        return res\n    elif content['kind'] == 'delegation':\n        return {'kind': content['kind'],\n                'target': content['delegate']}\n    else:\n        assert False, content['kind']\n\n\ndef format_stdout(items):\n    newline = True\n    depth = 0\n    res = []\n\n    def break_line():\n        JS(\"nonlocal newline // TODO transpile\")\n        JS(\"nonlocal res // TODO transpile\")\n        if not newline:\n            res.append('\\n')\n            newline = True\n\n    for item in items:\n        if item['action'] == 'begin':\n            break_line()\n            if item['prim'] not in ['parameter', 'storage', 'code', 'STORAGE', 'DUMP']:\n                res.extend(['  ' * depth, item['prim'], ':'])\n                depth += 1\n                newline = False\n        elif item['action'] == 'end':\n            depth -= 1\n            break_line()\n        elif item['action'] in ['message', 'event']:\n            res.append('  ' * depth if newline else ' ')\n            res.extend([item['text'], ';'])\n            newline = False\n        else:\n            assert False, item['action']\n\n    res = ''.join(res).strip('\\n')\n    if '\\n' not in res and all(map(lambda x: x['action'] != 'message', items)):\n        return ''\n\n    return res\n\n\ndef format_result(result):\n    if result is None:\n        return None\n    kind = result['kind']\n    if kind == 'message':\n        return result\n    elif kind == 'big_map_diff':\n        return {'value': list(map(format_diff, result['big_map_diff'])), **result}\n    elif kind == 'code':\n        return {'value': micheline_to_michelson(result['code']), **result}\n    elif kind == 'stack':\n        return {'value': list(map(format_stack_item, result['stack'])), **result}\n    elif kind == 'output':\n        operations = [format_content(x.get('_content')) for x in result['operations'].val_expr]\n        storage = [format_stack_item(result['storage'])]\n        big_map_diff = list(map(format_diff, result['big_map_diff']))\n        return {'value': (operations, storage, big_map_diff), **result}\n    else:\n        assert False, kind\n\n\ndef format_stderr(error):\n    ename = type(error).__name__\n    if isinstance(error, MichelsonRuntimeError):\n        evalue, traceback = error.message, 'at ' + ' -> '.join(error.trace)\n    elif isinstance(error, MichelsonParserError):\n        evalue, traceback = error.message, f'at line {error.line}, pos {error.pos}'\n    else:\n        evalue, traceback = pformat(error.args, compact=True), ''\n    return {'name': ename,\n            'value': evalue,\n            'trace': traceback}\n\n\nclass Interpreter:\n    \"\"\" Michelson interpreter reimplemented in Python.\n    Based on the following reference: https://michelson.nomadic-labs.com/\n    \"\"\"\n\n    def __init__(self, debug=True):\n        self.ctx = Context()\n        self.parser = MichelsonParser(extra_primitives=helpers_prim)\n        self.debug = debug\n\n    def execute(self, code):\n        \"\"\" Execute Michelson instructions (note that stack is not cleared after execution).\n\n        :param code: Michelson source (any valid Michelson expression or special helpers)\n        :returns: {\"success\": True|False, \"stdout\": \"\", \"stderr\": {}, \"result\": {\"value\": \"\", ...}}\n        \"\"\"\n        int_res = {'success': False}\n\n        try:\n            code_expr = michelson_to_micheline(code, parser=self.parser)\n        except MichelsonParserError as e:\n            if self.debug:\n                raise e\n            int_res['stderr'] = format_stderr(e)\n            return int_res\n\n        backup = deepcopy(self.ctx)\n\n        try:\n            res = do_interpret(self.ctx, code_expr)\n            if res is None and self.ctx.pushed:\n                res = {'kind': 'stack', 'stack': self.ctx.dump(count=1)}\n\n            int_res['result'] = format_result(res)\n            int_res['stdout'] = format_stdout(self.ctx.stdout)\n            int_res['success'] = True\n            self.ctx.reset()\n        except MichelsonRuntimeError as e:\n            int_res['stderr'] = format_stderr(e)\n            int_res['stdout'] = format_stdout(self.ctx.stdout)\n            self.ctx = backup\n\n            if self.debug:\n                if int_res.get('stdout'):\n                    print(int_res['stdout'])\n                raise e\n\n        if self.debug:\n            if int_res.get('stdout'):\n                print(int_res['stdout'])\n            if int_res.get('result'):\n                print('RESULT: ' + pformat(int_res['result']))\n\n        return int_res\n\n\n__all__ = [\"Interpreter\", \"format_content\", \"format_diff\", \"format_result\", \"format_stack_item\", \"format_stderr\", \"format_stdout\", \"get_content\"]\n"]}