{"version": 3, "mappings": "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", "sources": ["context.py"], "names": ["this.index", "this.self", "this.get_fresh_address", "nonce", "this.index.to_bytes", "nonce_hash", "blake2b", "blake2b({\"data\": nonce, \"digest_size\": 20}).digest", "res", "base58_encode", "base58_encode(nonce_hash, b'KT1'\n).decode", "this.stack", "this.meta", "this.dummy_gen", "DummyGen", "this.big_maps", "BigMapPool", "this.debug", "this.stdout", "list", "this[\"protected\"]", "this.pushed", "ctx", "Context", "ctx.stack", "deepcopy", "ctx.meta", "ctx.dummy_gen", "ctx.big_maps", "ctx.debug", "ctx[\"protected\"]", "ctx.pushed", "stack", "ctx.stdout", "this.stack.length", "count", "this.print", "assert_stack_item", "item", "this.stack.insert", "move", "item.rename", "annots", "body", "\", \".join", "map", "repr", "this.pop", "tuple", "this.meta.get", "key", "_default", "value", "micheline_to_michelson", "this.stack.clear", "min", "this.stdout.append", "message", "i", "match", "match.groups", "re", "re.sub", "format_stack_item", "template", "prim", "pformat"], "sourcesContent": ["import re\nfrom copy import deepcopy\nfrom pprint import pformat\nfrom typing import List\n\nfrom pytezos.crypto import blake2b\nfrom pytezos.encoding import base58_encode\nfrom pytezos.repl.types import StackItem, assert_stack_item\nfrom pytezos.michelson.converter import micheline_to_michelson\nfrom pytezos.repl.big_map import BigMapPool\n\n\nclass DummyGen:\n\n    def __init__(self):\n        self.index = 0\n        self.self = self.get_fresh_address()\n\n    def get_fresh_address(self):\n        nonce = JS(\"b'\\x00'\") * 32 + self.index.to_bytes(4, 'big')\n        nonce_hash = blake2b(data=nonce, digest_size=20).digest()\n        res = base58_encode(nonce_hash, JS(\"b'KT1'\")).decode()\n        self.index += 1\n        return res\n\n\nclass Context:\n\n    def __init__(self):\n        self.stack = []\n        self.meta = {}\n        self.dummy_gen = DummyGen()\n        self.big_maps = BigMapPool()\n        self.debug = True\n        self.stdout = list()\n        self.protected = 0\n        self.pushed = 0\n\n    def __deepcopy__(self, memodict={}):\n        ctx = Context()\n        ctx.stack = deepcopy(self.stack)\n        ctx.meta = deepcopy(self.meta)\n        ctx.dummy_gen = deepcopy(self.dummy_gen)\n        ctx.big_maps = deepcopy(self.big_maps)\n        ctx.debug = self.debug\n        ctx.protected = self.protected\n        ctx.pushed = self.pushed\n        return ctx\n\n    def spawn(self, stack):\n        ctx = Context()\n        ctx.stack = stack\n        ctx.meta = self.meta\n        ctx.dummy_gen = self.dummy_gen\n        ctx.big_maps = self.big_maps\n        ctx.debug = self.debug\n        ctx.stdout = self.stdout\n        return ctx\n\n    def reset(self):\n        self.stdout = []\n        self.pushed = False\n\n    def protect(self, count: int):\n        assert len(self.stack) >= count, f'got {len(self.stack)} items, wanted to protect {count}'\n        self.protected += count\n        self.print(f'protect {count} item(s)')\n\n    def restore(self, count: int):\n        assert self.protected >= count, f'wanted to restore {count}, only {self.protected} protected'\n        self.print(f'restore {count} item(s)')\n        self.protected -= count\n\n    def push(self, item: StackItem, annots=None, move=False):\n        assert_stack_item(item)\n        self.stack.insert(self.protected, item if move else item.rename(annots))\n        self.pushed = True\n        self.print(f'push {repr(item)}')\n\n    def peek(self):\n        assert len(self.stack) > 0, 'stack is empty'\n        return self.stack[self.protected]\n\n    def pop(self, count: int) -> List[StackItem]:\n        assert len(self.stack) - self.protected >= count, \\\n            f'got {len(self.stack) - self.protected} items, requested {count} '\n        res = [self.stack.pop(self.protected) for _ in range(count)]\n        if count <= 3:\n            body = ', '.join(map(repr, res))  # TODO: restrict line length\n        else:\n            body = f'{count} items'\n        self.print(f'pop {body}')\n        return res\n\n    def pop1(self):\n        res = self.pop(count=1)\n        return res[0]\n\n    def pop2(self):\n        return tuple(self.pop(count=2))\n\n    def pop3(self):\n        return tuple(self.pop(count=3))\n\n    def get(self, key, _default=None):\n        return self.meta.get(key, _default)\n\n    def set(self, key, value):\n        self.meta[key] = value\n        if key in ['parameter', 'storage', 'code', 'STORAGE']:\n            self.print(micheline_to_michelson({\"prim\": key, \"args\": [value]}, inline=True))\n        else:\n            self.print(f'set {key}={repr(value)}')\n\n    def unset(self, key):\n        if key in self.meta:\n            del self.meta[key]\n            self.print(f'unset {key}')\n\n    def drop_all(self):\n        self.stack.clear()\n        self.protected = 0\n        self.print(f'drop all')\n\n    def dump(self, count: int):\n        if len(self.stack) > 0:\n            count = min(count, len(self.stack))\n            return self.stack[:count]\n\n    def print(self, message):\n        if self.debug:\n            self.stdout.append({'action': 'event', 'text': message})\n\n    def printf(self, template: str):\n        def format_stack_item(match):\n            i = int(match.groups()[0])\n            assert i < len(self.stack), f'requested {i}th element, got only {len(self.stack)} items'\n            return repr(self.stack[i])\n\n        message = re.sub(r'\\{(\\d+)\\}', format_stack_item, template)\n        self.stdout.append({'action': 'message', 'text': message})\n\n    def begin(self, prim=None):\n        self.pushed = False\n        if self.debug:\n            self.stdout.append({'action': 'begin', 'prim': prim})\n\n    def end(self):\n        if self.debug:\n            self.stdout.append({'action': 'end'})\n\n    def __len__(self) -> int:\n        return len(self.stack)\n\n    def __repr__(self):\n        return pformat(self.stack)\n\n__all__ = [\"Context\", \"DummyGen\"]\n"]}