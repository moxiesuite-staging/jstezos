{"version": 3, "mappings": "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", "sources": ["grammar.py"], "names": ["ValueError", "message", "this.message", "this.line", "token", "token.lineno", "this.pos", "token.lexpos", "list", "Lexer", "this.lexer", "lex", "re", "re.MULTILINE", "t", "t.type", "t.value", "t.lexer", "t.lexer.skip", "object", "p", "json", "json.loads", "i", "p[0].extend", "p[0].append", "Sequence", "expr", "expand_macro", "this.extra", "AssertionError", "MichelsonParserError", "p.slice", "e", "SimpleMichelsonLexer", "this.parser", "yacc", "debug", "write_tables", "extra_primitives", "code", "code.length", "this.parser.parse"], "sourcesContent": ["# Inspired by https://github.com/jansorg/tezos-intellij/blob/master/grammar/michelson.bnf\nfrom ply.lex import Lexer, lex, LexToken\nfrom ply.yacc import yacc\nimport re\nimport json\n\nfrom pytezos.michelson.macros import expand_macro\n\n\nclass MichelsonParserError(ValueError):\n\n    def __init__(self, token: LexToken, message=None):\n        message = message or f'failed to parse expression {token}'\n        JS(\"super(MichelsonParserError, self).__init__(message)\")\n        self.message = message\n        self.line = token.lineno\n        self.pos = token.lexpos\n\n\nclass Sequence(list):\n    pass\n\n\nclass SimpleMichelsonLexer(Lexer):\n    tokens = ('INT', 'BYTE', 'STR', 'ANNOT', 'PRIM',\n              'LEFT_CURLY', 'RIGHT_CURLY', 'LEFT_PAREN', 'RIGHT_PAREN', 'SEMI')\n\n    t_INT = r'-?[0-9]+'\n    t_BYTE = r'0x[A-Fa-f0-9]*'\n    t_STR = r'\\\"(\\\\.|[^\\\"])*\\\"'\n    t_ANNOT = r'[:@%]+([_0-9a-zA-Z\\.]*)?'  # r'[:@%]+([_a-zA-Z][_0-9a-zA-Z\\.]*)?'\n    t_PRIM = r'[A-Za-z][A-Za-z0-9_]+'\n    t_LEFT_CURLY = r'\\{'\n    t_RIGHT_CURLY = r'\\}'\n    t_LEFT_PAREN = r'\\('\n    t_RIGHT_PAREN = r'\\)'\n    t_SEMI = r';'\n\n    t_ignore_MULTI_COMMENT = r'/\\*.*?\\*/'\n    t_ignore_COMMENT = r'#[^\\n]*'\n    t_ignore = ' \\t\\r\\n\\f'\n\n    def __init__(self):\n        JS(\"super(SimpleMichelsonLexer, self).__init__()\")\n        self.lexer = lex(module=self, reflags=re.MULTILINE)\n\n    def t_error(self, t):\n        t.type = t.value[0]\n        t.value = t.value[0]\n        t.lexer.skip(1)\n        return t\n\n\nclass MichelsonParser(object):\n    \"\"\" Customizable Michelson parser\n    \"\"\"\n    tokens = SimpleMichelsonLexer.tokens\n\n    def p_instr(self, p):\n        '''instr : expr\n                 | empty\n        '''\n        p[0] = p[1]\n\n    def p_instr_int(self, p):\n        '''instr : INT'''\n        p[0] = {'int': p[1]}\n\n    def p_instr_byte(self, p):\n        '''instr : BYTE'''\n        p[0] = {'bytes': p[1][2:]}  # strip 0x prefix\n\n    def p_instr_str(self, p):\n        '''instr : STR'''\n        p[0] = {'string': json.loads(p[1])}\n\n    def p_instr_list(self, p):\n        '''instr : instr SEMI instr'''\n        p[0] = list()\n        for i in [p[1], p[3]]:\n            if type(i) is list:\n                p[0].extend(i)\n            elif i is not None:\n                p[0].append(i)\n\n    def p_instr_subseq(self, p):\n        '''instr : LEFT_CURLY instr RIGHT_CURLY'''\n        p[0] = Sequence()\n        if type(p[2]) is list:\n            p[0].extend(p[2])\n        elif p[2] is not None:\n            p[0].append(p[2])\n\n    def p_expr(self, p):\n        '''expr : PRIM annots args'''\n        try:\n            expr = expand_macro(\n                prim=p[1],\n                annots=p[2] or [],\n                args=p[3] or [],\n                extra=self.extra\n            )\n        except AssertionError as e:\n            raise MichelsonParserError(p.slice[1], str(e))\n        p[0] = Sequence(expr) if isinstance(expr, list) else expr\n\n    def p_annots(self, p):\n        '''annots : annot\n                  | empty\n        '''\n        if p[1] is not None:\n            p[0] = [p[1]]\n\n    def p_annots_list(self, p):\n        '''annots : annots annot'''\n        p[0] = list()\n        if type(p[1]) == list:\n            p[0].extend(p[1])\n        if p[2] is not None:\n            p[0].append(p[2])\n\n    def p_annot(self, p):\n        '''annot : ANNOT'''\n        p[0] = p[1]\n\n    def p_args(self, p):\n        '''args : arg\n                | empty\n        '''\n        p[0] = list()\n        if p[1] is not None:\n            p[0].append(p[1])\n\n    def p_args_list(self, p):\n        '''args : args arg'''\n        p[0] = list()\n        if type(p[1]) == list:\n            p[0].extend(p[1])\n        if p[2] is not None:\n            p[0].append(p[2])\n\n    def p_arg_prim(self, p):\n        '''arg : PRIM'''\n        p[0] = {'prim': p[1]}\n\n    def p_arg_int(self, p):\n        '''arg : INT'''\n        p[0] = {'int': p[1]}\n\n    def p_arg_byte(self, p):\n        '''arg : BYTE'''\n        p[0] = {'bytes': p[1][2:]}  # strip 0x prefix\n\n    def p_arg_str(self, p):\n        '''arg : STR'''\n        p[0] = {'string': json.loads(p[1])}\n\n    def p_arg_subseq(self, p):\n        '''arg : LEFT_CURLY instr RIGHT_CURLY'''\n        if type(p[2]) == list:\n            p[0] = p[2]\n        elif p[2] is not None:\n            p[0] = [p[2]]\n        else:\n            p[0] = []\n\n    def p_arg_group(self, p):\n        '''arg : LEFT_PAREN expr RIGHT_PAREN'''\n        p[0] = p[2]\n\n    def p_empty(self, p):\n        '''empty :'''\n\n    def p_error(self, p):\n        raise MichelsonParserError(p)\n\n    def __init__(self, debug=False, write_tables=False, extra_primitives=None):\n        \"\"\" Initialize Michelson parser\n\n        :param debug: Verbose output\n        :param write_tables: Store PLY output\n        :param extra_primitives: List of words to be ignored\n        \"\"\"\n        self.lexer = SimpleMichelsonLexer()\n        self.parser = yacc(\n            module=self,\n            debug=debug,\n            write_tables=write_tables,\n        )\n        self.extra = extra_primitives\n\n    def parse(self, code):\n        \"\"\" Parse Michelson source.\n\n        :param code: Michelson source\n        :returns: Micheline expression\n        \"\"\"\n        if len(code) > 0 and code[0] == '(' and code[-1] == ')':\n            code = code[1:-1]\n        return self.parser.parse(code)\n\n\n__all__ = [\"MichelsonParser\", \"MichelsonParserError\", \"Sequence\", \"SimpleMichelsonLexer\"]\n"]}