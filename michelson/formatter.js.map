{"version": 3, "mappings": "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", "sources": ["formatter.py"], "names": ["dt", "datetime", "datetime.utcfromtimestamp", "timestamp", "dt.strftime", "ValueError", "node", "node[\"prim\"].startswith", "all", "map", "list", "is_script_root", "is_root", "is_script", "seq_indent", "indent", "items", "length", "indent.length", "sum", "len", "space", "inline", "line_size", "seq", "`${space}; `.join", "`${space};\n${seq_indent}`\n.join", "dict", "node.get", "expr", "\" \".join", "args", "is_complex", "arg_indent", "expr.length", "items.length", "`\n${arg_indent}`\n.join", "args.length", "alt_indent", "item", "format_node", "arg", "item.length", "is_inline", "is_framed", "wrapped", "core_type", "value", "json", "json.dumps", "res", "data", "wrap", "any", "res.startswith", "KeyError", "IndexError", "TypeError", "pprint", "MichelsonFormatterError", "e", "e.args"], "sourcesContent": ["import json\nfrom datetime import datetime\nfrom pprint import pprint\n\nline_size = 100\n\n\ndef format_timestamp(timestamp: int) -> str:\n    dt = datetime.utcfromtimestamp(timestamp)\n    return dt.strftime('%Y-%m-%dT%H:%M:%SZ')\n\n\nclass MichelsonFormatterError(ValueError):\n    pass\n\n\ndef is_framed(node):\n    if JS(\"\"\"node['prim'] in {'Pair', 'Left', 'Right', 'Some',\n                        'pair', 'or', 'option', 'map', 'big_map', 'list', 'set', 'contract', 'lambda'} // TODO transpile\"\"\"):\n        return True\n    elif JS(\"\"\"node['prim'] in {'key', 'unit', 'signature', 'operation',\n                          'int', 'nat', 'string', 'bytes', 'mutez', 'bool', 'key_hash', 'timestamp', 'address'} // TODO transpile\"\"\"):\n        return 'annots' in node\n    return False\n\n\ndef is_complex(node):\n    return node['prim'] == 'LAMBDA' \\\n           or node['prim'].startswith('IF')\n\n\ndef is_inline(node):\n    return node['prim'] == 'PUSH'\n\n\ndef is_script(node):\n    return all(map(\n        lambda x: isinstance(x, dict) and x.get('prim') in ['parameter', 'storage', 'code'],\n        node))\n\n\ndef format_node(node, indent='', inline=False, is_root=False, wrapped=False):\n    if isinstance(node, list):\n        is_script_root = is_root and is_script(node)\n        seq_indent = indent if is_script_root else indent + ' ' * 2\n        items = list(map(lambda x: format_node(x, seq_indent, inline, wrapped=True), node))\n        if items:\n            length = len(indent) + sum(map(len, items)) + 4\n            space = '' if is_script_root else ' '\n            if inline or length < line_size:\n                seq = f'{space}; '.join(items)\n            else:\n                seq = f'{space};\\n{seq_indent}'.join(items)\n            return seq if is_script_root else f'{{ {seq} }}'\n        else:\n            return '{}'\n\n    elif isinstance(node, dict):\n        if node.get('prim'):\n            expr = ' '.join([node['prim']] + node.get('annots', []))\n            args = node.get('args', [])\n\n            if is_complex(node):\n                arg_indent = indent + ' ' * 2\n                items = list(map(lambda x: format_node(x, arg_indent, inline), args))\n                length = len(indent) + len(expr) + sum(map(len, items)) + len(items) + 1\n                if inline or length < line_size:\n                    expr = f'{expr} {\" \".join(items)}'\n                else:\n                    expr = f'\\n{arg_indent}'.join([expr] + items)\n\n            elif len(args) == 1:\n                arg_indent = indent + ' ' * (len(expr) + 1)\n                expr = f'{expr} {format_node(args[0], arg_indent, inline)}'\n\n            elif len(args) > 1:\n                arg_indent = indent + ' ' * 2\n                alt_indent = indent + ' ' * (len(expr) + 2)\n                for arg in args:\n                    item = format_node(arg, arg_indent, inline)\n                    length = len(indent) + len(expr) + len(item) + 1\n                    if inline or is_inline(node) or length < line_size:\n                        arg_indent = alt_indent\n                        expr = f'{expr} {item}'\n                    else:\n                        expr = f'{expr}\\n{arg_indent}{item}'\n\n            if is_framed(node) and not is_root and not wrapped:\n                return f'({expr})'\n            else:\n                return expr\n        else:\n            JS(\"core_type, value = next((k, v) for k, v in node.items() if k[0] != '_' and k != 'annots') // TODO transpile\")\n            if core_type == 'int':\n                return value\n            elif core_type == 'bytes':\n                return f'0x{value}'\n            elif core_type == 'string':\n                return json.dumps(value)\n            else:\n                assert False, f'unexpected core node {node}'\n    else:\n        assert False, f'unexpected node {node}'\n\n\ndef micheline_to_michelson(data, inline=False, wrap=False):\n    \"\"\"\n    Converts micheline expression into formatted Michelson source\n    :param data: Micheline expression\n    :param inline: produce single line, used for tezos-client arguments (False by default)\n    :param wrap: ensure expression is wrapped in brackets\n    :return: string\n    \"\"\"\n    try:\n        res = format_node(data, inline=inline, is_root=True)\n        if wrap and any(map(res.startswith, ['Left', 'Right', 'Some', 'Pair'])):\n            return f'({res})'\n        else:\n            return res\n    except (KeyError, IndexError, TypeError) as e:\n        pprint(data, compact=True)\n        raise MichelsonFormatterError(e.args)\n\n\n__all__ = [\"MichelsonFormatterError\", \"format_node\", \"format_timestamp\", \"is_complex\", \"is_framed\", \"is_inline\", \"is_script\", \"micheline_to_michelson\", \"line_size\"]\n"]}