{"version": 3, "mappings": "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", "sources": ["pack.py"], "names": ["type_prim", "type_args", "parse_prim_expr", "type_node", "is_string", "val_node", "dict", "val_node.get", "try_pack", "type_idx", "forge_base58", "forge_base58(val_node[\"string\"]).hex", "forge_address", "forge_address(val_node[\"string\"], {\"tz_only\": true}).hex", "forge_public_key", "forge_public_key(val_node[\"string\"]).hex", "forge_address(val_node[\"string\"]).hex", "forge_contract", "forge_contract(val_node[\"string\"]).hex", "forge_timestamp", "val_expr", "type_expr", "data", "prepack_micheline", "bin_path", "bin_path.length", "node", "idx", "blake2b_32", "pack", "blake2b_32(pack(val_expr, type_expr)).digest", "base58_encode", "base58_encode(data, b'expr' // TODO transpile\n).decode", "data.startswith", "parsed", "unforge_micheline"], "sourcesContent": ["from pytezos.crypto import blake2b_32\nfrom pytezos.encoding import forge_base58, forge_address, forge_public_key, forge_contract, forge_timestamp, \\\n    base58_encode\nfrom pytezos.michelson.forge import forge_micheline, unforge_micheline\nfrom pytezos.repl.parser import parse_prim_expr\n\n\ndef prepack_micheline(val_expr, type_expr):\n    def try_pack(val_node, type_node):\n        type_prim, type_args = parse_prim_expr(type_node)\n        is_string = isinstance(val_node, dict) and val_node.get('string')\n\n        if type_prim in ['set', 'list']:\n            val_node = [try_pack(i, type_args[0]) for i in val_node]\n        elif type_prim in ['map', 'big_map']:\n            val_node = [{'prim': 'Elt', 'args': [try_pack(elt['args'][i], type_args[i]) for i in [0, 1]]}\n                        for elt in val_node]\n        elif type_prim == 'pair':\n            val_node['args'] = [try_pack(val_node['args'][i], type_args[i]) for i in [0, 1]]\n        elif type_prim == 'option':\n            if val_node['prim'] == 'Some':\n                val_node['args'] = [try_pack(val_node['args'][0], type_args[0])]\n        elif type_prim == 'or':\n            type_idx = 0 if val_node['prim'] == 'Left' else 1\n            val_node['args'] = [try_pack(val_node['args'][0], type_args[type_idx])]\n        elif type_prim == 'lambda':\n            pass  # TODO: PUSH, SELF, CONTRACT\n        elif type_prim == 'chain_id' and is_string:\n            return {'bytes': forge_base58(val_node['string']).hex()}\n        elif type_prim == 'signature' and is_string:\n            return {'bytes': forge_base58(val_node['string']).hex()}\n        elif type_prim == 'key_hash' and is_string:\n            return {'bytes': forge_address(val_node['string'], tz_only=True).hex()}\n        elif type_prim == 'key' and is_string:\n            return {'bytes': forge_public_key(val_node['string']).hex()}\n        elif type_prim == 'address' and is_string:\n            return {'bytes': forge_address(val_node['string']).hex()}\n        elif type_prim == 'contract' and is_string:\n            return {'bytes': forge_contract(val_node['string']).hex()}\n        elif type_prim == 'timestamp' and is_string:\n            return {'int': forge_timestamp(val_node['string'])}\n\n        return val_node\n\n    return try_pack(val_expr, type_expr)\n\n\ndef pack(val_expr, type_expr):\n    data = prepack_micheline(val_expr, type_expr)\n    return JS(\"b'\\x05' + forge_micheline(data) // TODO Transpile\")\n\n\ndef get_sub_expr(type_expr, bin_path='0'):\n    assert len(bin_path) > 0, f'binary path should be at least `0`'\n    node = type_expr\n    for idx in bin_path[1:]:\n        assert isinstance(node, dict), f'type expression contains dict nodes only'\n        node = node['args'][int(idx)]\n    return node\n\n\ndef get_key_hash(val_expr, type_expr, bin_path=''):\n    for idx in bin_path:\n        assert isinstance(type_expr, dict), f'type expression contains dict nodes only'\n        type_expr = type_expr['args'][int(idx)]\n\n    data = blake2b_32(pack(val_expr, type_expr)).digest()\n    return base58_encode(data, JS(\"b'expr' // TODO transpile\")).decode()\n\n\ndef unpack(data: bytes, type_expr):\n    assert data.startswith(JS(\"b'\\x05') // TODO transpile\"), f'packed data should start with 05')\n    parsed = unforge_micheline(data[1:])\n    return parsed\n\n\n__all__ = [\"get_key_hash\", \"get_sub_expr\", \"pack\", \"prepack_micheline\", \"unpack\"]\n"]}