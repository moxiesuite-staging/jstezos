{"version": 3, "mappings": "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", "sources": ["docstring.py"], "names": ["docstring", "list", "known_types", "set", "schema", "schema.metadata", "bin_path", "name", "schema.bin_names", "schema.bin_names.get", "next", "_default", "get_name", "schema.metadata[bin_path].get", "node", "node.get", "get_node", "bin_type", "schema.bin_types", "root", "struct_name", "title", "is_element", "get_type", "entries", "x", "doc", "\" || \\n\\t\".join", "map", "entries.items", "res", "get_struct_name", "docstring.insert", "\" || \".join", "items", "lines", "\",\\n\\t\".join", "values", "decode_node", "value", "item", "core_types", "is_entry", "comment", "get_comment", "parameter", "is_optional", "domain_types", "known_types.add", "docstring.append", "\"\\n\".join"], "sourcesContent": ["from os.path import basename\n\nfrom pytezos.michelson.micheline import Schema, is_optional\n\ncore_types = ['string', 'int', 'bool']\ndomain_types = {\n    'nat': 'int  /* Natural number */',\n    'unit': 'Unit || None /* Void */',\n    'bytes': 'string  /* Hex string */ ||\\n\\tbytes  /* Python byte string */',\n    'timestamp': 'int  /* Unix time in seconds */ ||\\n\\tstring  /* Formatted datetime `%Y-%m-%dT%H:%M:%SZ` */',\n    'mutez': 'int  /* Amount in `utz` (10^-6) */ ||\\n\\tDecimal  /* Amount in `tz` */',\n    'contract': 'string  /* Base58 encoded `KT` address */',\n    'address': 'string  /* Base58 encoded `tz` or `KT` address */',\n    'key': 'string  /* Base58 encoded public key */',\n    'key_hash': 'string  /* Base58 encoded public key hash */',\n    'signature': 'string  /* Base58 encoded signature */',\n    'lambda': 'string  /* Michelson source code */'\n}\n\n\ndef generate_docstring(schema: Schema, title, root='0') -> str:\n    \"\"\" Generate Michelson type (of arbitrary complexity) documentation in a more readable form.\n\n    :param schema: parameter/storage schema\n    :param title: documentation title\n    :param root: binary path to the root element (default is '0')\n    :returns: formatted docstring\n    \"\"\"\n    docstring = list()\n    known_types = set()\n\n    def get_node(bin_path):\n        return schema.metadata[bin_path]\n\n    def get_name(bin_path):\n        name = schema.bin_names.get(bin_path)\n        if not name:\n            name = next((JS(\"basename(k) for k, v in schema.json_to_bin.items() if v == bin_path\")), bin_path)\n        return name\n\n    def get_type(bin_path):\n        _default = get_name(bin_path[:-1]) + '_item'\n        return schema.metadata[bin_path].get('typename', _default)\n\n    def get_comment(bin_path):\n        node = schema.metadata[bin_path]\n        return node.get('typename', node.get('fieldname'))\n\n    def decode_node(bin_path, is_element=False, is_entry=False):\n        node = get_node(bin_path)\n        bin_type = schema.bin_types[bin_path]\n\n        def get_struct_name():\n            if bin_path == root:\n                struct_name = title\n            elif is_element:\n                struct_name = get_type(bin_path)\n            else:\n                struct_name = get_name(bin_path)\n            return f'${struct_name}'\n\n        if bin_type == 'router':\n            entries = {get_name(x): JS(\"decode_node(x, is_entry=True) for x in node['args']\")}\n            doc = ' || \\n\\t'.join(map(lambda x: '{ ' + f'\"{x[0]}\": {x[1]}' + ' }', entries.items()))\n            res = get_struct_name()\n            docstring.insert(0, f'{res}:\\n\\t{doc}\\n')\n            return res\n\n        elif bin_type == 'enum':\n            res = ' || '.join(map(lambda x: f'\"{get_name(x)}\"', node['args']))\n\n        elif bin_type == 'namedtuple':\n            items = map(lambda x: (get_name(x), decode_node(x)), node['args'])\n            lines = map(lambda x: f'  \"{x[0]}\": {x[1]}', items)\n            doc = '\\t{\\n\\t' + ',\\n\\t'.join(lines) + '\\n\\t}'\n            res = get_struct_name()\n            docstring.insert(0, f'{res}:\\n{doc}\\n')\n            return res\n\n        elif bin_type == 'tuple':\n            values = map(decode_node, node['args'])\n            res = f'[ {\" , \".join(values)} ]'\n\n        elif JS(\"bin_type in {'keypair', 'pair'}\"):\n            values = map(decode_node, node['args'])\n            res = f'( {\" , \".join(values)} )'\n\n        elif JS(\"bin_type in {'set', 'list'}\"):\n            value = decode_node(node['args'][0], is_element=True)\n            res = f'[ {value} , ... ]'\n\n        elif JS(\"bin_type in {'map', 'big_map'}\"):\n            item = (decode_node(node['args'][0]), decode_node(node['args'][1], is_element=True))\n            res = '{ ' + f'{item[0]} : {item[1]} , ...' + ' }'\n            if bin_type == 'big_map':\n                res += '  /* big_map */'\n\n        else:\n            res = node['prim']\n            if res not in core_types:\n                res = f'${res}'\n\n            if is_entry:\n                comment = get_comment(bin_path)\n                if comment:\n                    res = f'{res}  /* {comment} */'\n\n            if node['prim'] in ['contract', 'lambda']:\n                parameter = schema.metadata[bin_path]['parameter']\n                res = f'{res} ({parameter})'\n\n            if is_optional(schema, bin_path):\n                res = f'None || {res}'\n\n            if node['prim'] not in core_types:\n                if bin_path == root:\n                    res = domain_types[node[\"prim\"]]\n                else:\n                    assert node['prim'] in domain_types, f'not a domain type {node[\"prim\"]}'\n                    known_types.add(node['prim'])\n\n        if bin_path == root:\n            docstring.insert(0, f'${title}:\\n\\t{res}\\n')\n\n        return res\n\n    decode_node(root)\n\n    for prim in known_types:\n        docstring.append(f'${prim}:\\n\\t{domain_types[prim]}\\n')\n\n    return '\\n'.join(docstring)\n\n\n__all__ = [\"generate_docstring\", \"core_types\", \"domain_types\"]\n"]}