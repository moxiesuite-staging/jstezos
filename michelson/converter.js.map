{"version": 3, "mappings": "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", "sources": ["converter.py"], "names": ["ValueError", "metadata", "collapse_micheline", "code", "Schema", "build_maps", "KeyError", "TypeError", "pprint", "MichelineSchemaError", "e", "e.args", "parse_micheline", "val_expr", "type_expr", "schema", "root", "IndexError", "generate_docstring", "bin_values", "parse_json", "data", "make_micheline", "schema.bin_types", "binary", "source", "michelson_to_micheline", "encode_micheline", "is_micheline", "output", "micheline_to_michelson", "inline", "bin_to_id", "dict", "id_to_bin", "path", "path.length", "node", "node.get", "get_big_map_id", "schema.bin_types.items", "prim", "big_map_id", "bin_path", "BigMapSchema", "value", "list", "x", "x.get", "primitives", "prim_tags", "prim_tags.keys", "any", "map"], "sourcesContent": ["from pprint import pprint\nfrom collections import namedtuple\n\nfrom pytezos.michelson.forge import prim_tags\nfrom pytezos.michelson.micheline import Schema, collapse_micheline, build_maps, parse_micheline, \\\n    parse_json, make_micheline, michelson_to_micheline\nfrom pytezos.michelson.formatter import micheline_to_michelson\nfrom pytezos.michelson.docstring import generate_docstring\n\nBigMapSchema = namedtuple('BigMapSchema', ['bin_to_id', 'id_to_bin'])\n\n\nclass MichelineSchemaError(ValueError):\n    pass\n\n\ndef build_schema(code) -> Schema:\n    \"\"\"\n    Creates internal structures necessary for decoding/encoding micheline:\n    `metadata` -> micheline tree with collapsed `pair`, `or`, and `option` nodes\n    `bin_types` -> maps binary path to primitive\n    `bin_names` -> binary path to key name mapping\n    `json_to_bin` -> json path to binary path mapping\n    :param code: parameter or storage section of smart contract source code (in micheline)\n    :return: Schema\n    \"\"\"\n    try:\n        metadata = collapse_micheline(code)\n        return Schema(metadata, *build_maps(metadata))\n    except (KeyError, ValueError, TypeError) as e:\n        pprint(code, compact=True)\n        raise MichelineSchemaError(f'Failed to build schema', e.args)\n\n\ndef decode_micheline(val_expr, type_expr, schema: Schema, root='0'):\n    \"\"\"\n    Converts Micheline data into Python object\n    :param val_expr: Micheline value expression\n    :param type_expr: Michelson type expression for the entire type\n    :param schema: schema built for particular contract/section\n    :param root: which binary node to take as root, used to decode BigMap values/diffs\n    :return: Object\n    \"\"\"\n    try:\n        return parse_micheline(val_expr, type_expr, schema, root)\n    except (KeyError, IndexError, TypeError) as e:\n        print(generate_docstring(schema, 'schema'))\n        pprint(val_expr, compact=True)\n        raise MichelineSchemaError(f'Failed to decode micheline expression', e.args)\n\n\ndef encode_micheline(data, schema: Schema, root='0', binary=False):\n    \"\"\"\n    Converts Python object into Micheline expression\n    :param data: Python object\n    :param schema: schema built for particular contract/section\n    :param root: which binary node to take as root, used to encode BigMap values\n    :param binary: Encode keys and addresses in bytes rather than strings, default is False\n    :return: Micheline expression\n    \"\"\"\n    try:\n        bin_values = parse_json(data, schema, root)\n        return make_micheline(bin_values, schema.bin_types, root, binary)\n    except (KeyError, IndexError, TypeError) as e:\n        print(generate_docstring(schema, 'schema'))\n        pprint(data, compact=True)\n        raise MichelineSchemaError(f'Failed to encode micheline expression', e.args)\n    else:\n        print(\"WORKS?!\")\n\n\ndef convert(source, schema: Schema = None, output='micheline', inline=False):\n    \"\"\"\n    Convert data between different representations (DO NOT USE FOR STORAGE/PARAMETER, can be ambiguous)\n    :param source: Data, can be one of Michelson (string), Micheline expression, object\n    :param schema: Needed if decoding/encoding objects (optional)\n    :param output: Output format, one of 'micheline' (default), 'michelson', 'object'\n    :param inline: Used for michelson output, whether to omit line breaks\n    \"\"\"\n    if isinstance(source, str):\n        try:\n            source = michelson_to_micheline(source)\n        except ValueError:\n            assert schema\n            source = encode_micheline(source, schema)\n    elif not is_micheline(source):\n        assert schema\n        source = encode_micheline(source, schema)\n\n    if output == 'michelson':\n        return micheline_to_michelson(source, inline)\n    elif output == 'object':\n        assert False, f'not supported'\n    elif output == 'micheline':\n        return source\n    else:\n        assert False, output\n\n\ndef build_big_map_schema(data, schema: Schema) -> BigMapSchema:\n    bin_to_id = dict()\n    id_to_bin = dict()\n\n    def get_big_map_id(node, path):\n        if len(path) == 0:\n            assert node.get('int'), (node, path)\n            return int(node['int'])\n        else:\n            assert node.get('args'), (node, path)\n            return get_big_map_id(node['args'][int(path[0])], path[1:])\n\n    for bin_path, prim in schema.bin_types.items():\n        if prim == 'big_map':\n            big_map_id = get_big_map_id(data, bin_path[1:])\n            bin_to_id[bin_path], id_to_bin[big_map_id] = big_map_id, bin_path\n\n    return BigMapSchema(bin_to_id, id_to_bin)\n\n\ndef is_micheline(value):\n    if isinstance(value, list):\n        def get_prim(x):\n            return x.get('prim') if isinstance(x, dict) else None\n        JS(\"return set(map(get_prim, value)) == {'parameter', 'storage', 'code'} // TODO transpile\")\n    elif isinstance(value, dict):\n        primitives = list(prim_tags.keys())\n        return any(map(lambda x: x in value, ['prim', 'args', 'annots', *primitives]))\n    else:\n        return False\n\n__all__ = [\"build_big_map_schema\", \"build_schema\", \"convert\", \"decode_micheline\", \"encode_micheline\", \"is_micheline\", \"BigMapSchema\"]\n"]}