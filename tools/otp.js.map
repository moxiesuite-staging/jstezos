{"version": 3, "mappings": "AAAA,QAAA,MAAA;AAEA,QAAA,MAAA;AACA,QAAA,GAAA;AACA,QAAA,OAAA;AAGA,SAAA;IAEI,4BAAiC,CAAjC,UAA0CA,OAA1C;QAKJ;QAAA;QAAA;QAAA;QAAA;QACQ,IAAG,EAAA,CAAI,CAAWC,GAAX,WAAA,CAAgBC,GAAhB,CAAJ,CAAH;YACI,IAAGC,MAAA,CAAOF,GAAP,CAAH;gBACIA,MAAMG,KAAAC,WAAA,CAAiBJ,GAAjB;YADV;YAEAA,MAAMC,GAAAI,iBAAA,CAAqBL,GAArB;QAHV;QAKA,IAAAM,QAAYN;QACZ,IAAAO,aAAiBC;QACjB,IAAAC,UAAcN;IAblB;IAeA;;QACI,IAAG,EAAA,CAAI,IAAAG,KAAAI,gBAAJ,CAAH;YACI,MAAM,IAAAC,UAAA,CAAW,0CAAX;QADV;QAGAC,UAAU,IAAAH,OAAAI,KAAAC,eAAA;QACVC,MAAAC,MAAA,CAAa,wBAAb;QAEA,OAAO,IAAAV,KAAAW,KAAA,CAAeL,OAAf;IAPX;IASA;;QACIM,eAAe,IAAAT,OAAAU,OAAA,YAA0B,IAAAZ,WAA1B;QAEf,iCAAWW,kCAAX,iBAAA,YAAA;;YACI;gBACIN,UAAUQ,GAAA,CAAI,CAAJ;gBACVL,MAAAC,MAAA,CAAa,gBAAb;gBAEA,IAAAV,KAAAe,OAAA,CAAiBC,SAAjB,EAA4BV,OAA5B;gBAIA,OAAO;YARX;kCAKOD;oBACHI,MAAAC,MAAA,CAAiBO,UAAJ,EAAb;;;;YANJ;QADJ;QAWA,OAAO;IAdX;AA1BJ", "sources": ["otp.py"], "names": ["mainnet", "key", "Key", "is_pkh", "shell", "shell.public_key", "Key.from_encoded_key", "this._key", "this._interval", "interval", "this._shell", "this._key.secret_exponent", "ValueError", "message", "this._shell.head", "this._shell.head.calculate_hash", "logger", "logger.debug", "this._key.sign", "block_hashes", "this._shell.blocks", "row", "this._key.verify", "signature", "e"], "sourcesContent": ["from loguru import logger\n\nfrom pytezos.encoding import is_pkh\nfrom pytezos.crypto import Key\nfrom pytezos.rpc import mainnet\n\n\nclass OTP:\n\n    def __init__(self, key, interval=5, shell=mainnet):\n        \"\"\"\n        :param key: secret key (encrypted/unencrypted), public key or public key hash, all base58 encoded\n        :param interval: number of blocks to check (tolerance)\n        :param shell: ShellQuery instance\n        \"\"\"\n        if not isinstance(key, Key):\n            if is_pkh(key):\n                key = shell.public_key(key)\n            key = Key.from_encoded_key(key)\n\n        self._key = key\n        self._interval = interval\n        self._shell = shell\n\n    def now(self) -> str:\n        if not self._key.secret_exponent:\n            raise ValueError('Cannot generate OTP without a secret key')\n\n        message = self._shell.head.calculate_hash()\n        logger.debug(f'block hash: {message}')\n\n        return self._key.sign(message)\n\n    def verify(self, signature) -> bool:\n        block_hashes = self._shell.blocks(length=self._interval)\n\n        for row in block_hashes:\n            try:\n                message = row[0]\n                logger.debug(f'try {message}')\n\n                self._key.verify(signature, message)\n            except ValueError as e:\n                logger.debug(str(e))\n            else:\n                return True\n\n        return False\n"]}