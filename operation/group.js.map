{"version": 3, "mappings": "AAAA,QAAA,OAAA;AAEA,QAAA,UAAA;AACA,QAAA,YAAA;AACA,QAAA,qBAAA;AACA,QAAA,aAAA,EAAA,WAAA,EAAA,iBAAA,EAAA,qBAAA;AACA,QAAA,eAAA;AACA,QAAA,QAAA;AACA,QAAA,aAAA,EAAA,YAAA;AACA,QAAA,OAAA;AACA,QAAA,mBAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAiBA,oBAAA,SAAqBA,OAArB;IAGA;IAAA;IAAA;IAEI,uBAA4B,IAA5B,aAA2C,IAA3C,aAA0D,IAA1D,WAAuE,IAAvE,cAAuF,IAAvF,UAAmG,IAAnG,QAA6G,IAA7G;QACI;QACA,IAAAC,YAAgB,CAAAC,QAAA,GAAA,CAAY,EAAZ;QAChB,IAAAC,YAAgBC;QAChB,IAAAC,YAAgBC;QAChB,IAAAC,UAAcC;QACd,IAAAC,aAAiBC;IANrB;IAQA;;QACIC,MAAM,MACFC,SAAA,EADE,EAEF,WAFE,EAGFC,OAAA,CAAQ,IAAAC,aAAA,EAAR,CAHE,EAIF,WAJE,EAKFC,mBAAA,CAAoB,IAAAC,UAApB,CALE;QAON,OAAO,IAAAC,KAAA,CAAUN,GAAV;IARX;IAUA,kBAAA;QACI,OAAO,IAAAO,cAAA,cACMC,MAAAC,IAAA,CAAW,UAAX,EAAuB,IAAAnB,SAAAoB,KAAA,EAAvB,eACAF,MAAAC,IAAA,CAAW,UAAX,EAAuB,IAAAjB,SAAvB,eACAgB,MAAAC,IAAA,CAAW,UAAX,EAAuB,IAAAf,SAAvB,aACFc,MAAAC,IAAA,CAAW,QAAX,EAAqB,IAAAb,OAArB,gBACGY,MAAAC,IAAA,CAAW,WAAX,EAAwB,IAAAX,UAAxB,YACJU,MAAAC,IAAA,CAAW,OAAX,EAAoB,IAAAE,MAApB,UACFH,MAAAC,IAAA,CAAW,KAAX,EAAkB,IAAAG,IAAlB,EAPD;IADX;IAWA;QAEJ;QAAA;QACQ,OAAO,CACH,UADG,EACS,IAAApB,SADT,EAEH,QAFG,EAEO,IAAAI,OAFP,EAGH,UAHG,EAGS,IAAAN,SAHT,EAIH,WAJG,EAIU,IAAAQ,UAJV;IAHX;IAUA;QAEJ;QAAA;QACQ,IAAG,EAAA,CAAI,IAAAA,UAAJ,CAAH;YACI,MAAM,IAAAe,UAAA,CAAW,YAAX;QADV;QAGA,OAAO,CAAAC,KAAAC,QAAA,CAAc,IAAAC,MAAA,EAAd,CAAA,EAAA,CAA8BC,YAAA,CAAa,IAAAnB,UAAb,CAA9B;IANX;IAQA;QAKJ;QAAA;QAAA;QAAA;QAAA;QACQ,OAAO,IAAAoB,OAAA,cAAqB,CAAA,IAAA5B,SAAA,EAAA,CAAgB,CAAC6B,OAAD,CAAhB,EAArB;IANX;IAQA;QAKJ;QAAA;QAAA;QAAA;QAAA;;;QACQxB,WAAW,CAAA,IAAAD,SAAA,GAAA,CAAiB,IAAAiB,MAAAS,OAAAC,KAAAC,SAAA,EAAjB;QACXzB,SAAS,CAAA,IAAAD,OAAA,GAAA,CAAe,IAAAe,MAAAY,KAAAC,YAAAC,KAAA,EAAf;QACThC,WAAW,CAAA,IAAAD,SAAA,GAAA,CAAiB,IAAAmB,MAAAY,KAAAG,OAAA,EAAA,CAAyB,UAAzB,CAAjB;QACXC,SAAS,IAAAf,IAAAgB,gBAAA;QACTC,UAAU,IAAAlB,MAAAmB,UAAA,CAAqBH,MAArB,CAAAI,MAAA;QAEVC,cAAc,CACV,KADU,EACHL,MADG,EAEV,QAFU,EAEAA,MAFA,EAGV,UAHU,EAGEA,MAHF,EAIV,SAJU,gDAIC,CAJD,EAKV,QALU,gDAKA,CALA,EAMV,QANU,kEAMA,CANA,EAOV,YAPU,6CAOI,CAPJ,EAQV,gBARU,EAQQA,MARR,EASV,KATU,iDASH,CATG,EAUV,WAVU,uDAUG,CAVH,EAWV,eAXU,2DAWO,CAXP;;;;;;;;;;;;;;;QAcd;YACIR,UAAUA,OAAAc,KAAA;YACV,kCAAYD,WAAAE,MAAA,wBAAZ,iBAAA,YAAA;;;gBACI,cAAG,CAAAf,OAAAgB,IAAA,CAAYC,CAAZ,CAAA,EAAkB,CAAC,EAAD,EAAK,GAAL,CAAlB,CAAH;oBACIjB,OAAA,CAAQiB,CAAR,IAAa,CAAc,EAASC,sBAAT,GAAA,UAASA,kBAAT,CAAd,GAAAA,CAAA,CAAElB,OAAF,CAAA,GAA+BkB,CAA/B;gBADjB;YADJ;YAGA,OAAOlB;QALX;QAOA,OAAO,IAAAD,OAAA,cACMoB,IAAA,CAAKC,GAAA,CAAIC,YAAJ,EAAkB,IAAAlD,SAAlB,CAAL,eACAG,sBACAE,oBACFE,OAJJ;IAjCX;IAwCA;QAIJ;QAAA;QAAA;QAAA;QACQ,OAAO,IAAAc,MAAAY,KAAAkB,QAAAC,QAAAC,cAAAC,KAAA,CAAmD,CACtD,WADsD,EACzC,CACT,QADS,EACC,IAAAhD,OADD,EAET,UAFS,EAEG,IAAAN,SAFH,EAGT,WAHS,EAGIuD,aAAA,CAAc,QAAA,CAAa,EAAb,CAAd,UAAAC,OAAA,EAHJ,CADyC,EAMtD,UANsD,EAM1C,IAAApD,SAN0C,CAAnD;;;IALX;IAcA,iBAAyB,IAAzB;QAKJ;QAAA;QAAA;QAAA;QAAA;;QACQqD,UAAU,CACN,QADM,EACI,IAAAnD,OADJ,EAEN,UAFM,EAEM,IAAAN,SAFN;QAIV0D,aAAaC,qBAAA,CAAsBF,OAAtB,CAAAG,IAAA;QAEb,IAAGC,QAAH;YACIC,cAAc,IAAAzC,MAAA0C,OAAA,CAAkB,IAAAzD,OAAlB,CAAA0D,QAAAC,MAAAC,WAAAC,KAAA,CAA6DV,OAA7D;YACd,IAAG,CAAAC,UAAA,IAAA,CAAcI,WAAd,CAAH;gBACI,MAAM,IAAAvC,UAAA;;;;;;YADV;QAFJ;QAKA,OAAOmC;IAjBX;IAmBA,uBAA+B,GAA/B;QAKJ;QAAA;QAAA;QAAA;QAAA;;;QACQU,MAAM,IAAAC,KAAA;QACNC,oBAAoBF,GAAAG,IAAA;QACpB,IAAG,EAAA,CAAIC,eAAAC,WAAA,CAA2BH,iBAA3B,CAAJ,CAAH;YACI,MAAMI,QAAAC,YAAA,CAAqBH,eAAAI,OAAA,CAAuBN,iBAAvB,CAArB;QADV;QAGAO;;QAEA;;YACI,IAAG,CAAAC,iBAAA,CAAkBjD,OAAA,CAAQ,MAAR,CAAlB,CAAA,IAAA,CAAsC,CAAtC,CAAH;gBACIkD,eAAe,CAAAP,eAAAQ,aAAA,CAA6BnD,OAA7B,CAAA,EAAA,CAAwCoD,WAAxC;gBACfC,yBAAyBV,eAAAW,uBAAA,CAAuCtD,OAAvC;gBACzBuD,SAASZ,eAAAa,OAAA,CAAuBxD,OAAvB;gBACTyD,MAAMC,aAAA,CAAc1D,OAAd,EAAuBkD,YAAvB,EAAqCF,UAArC;gBACNhD,OAAA2D,OAAA,eACkB,CAAAT,YAAA,EAAA,CAAeE,WAAf,UAAJ,qBACQ,CAAAC,sBAAA,EAAA,CAAyBE,MAAzB,UAAJ,WACNE,YAAJ,GAHR;YALJ;YAWAzD,OAAA4D,IAAA,CAAY,UAAZ;YACA,OAAO5D;QAbX;QAeAuC,GAAAsB,YAAe1C,IAAA,CAAKC,GAAA,CAAIC,YAAJ,EAAkBoB,iBAAA,CAAkB,UAAlB,CAAlB,CAAL;QACf,OAAOF;IA7BX;IA+BA;QAIJ;QAAA;QAAA;QAAA;;QACQuB,kBAAkBb,iBAAA,CAAkB,IAAA9E,SAAA,CAAc,CAAd,CAAA,CAAiB,MAAjB,CAAlB;QAClB,IAAG4F,GAAA,CAAI3C,GAAA,yEAAI,CAAJ,EAA+D,IAAAjD,SAA/D,CAAJ,CAAH;;;YACI,MAAM,IAAAuB,UAAA,CAAW,yBAAX;QADV;QAGA,IAAG,CAAAoE,eAAA,IAAA,CAAmB,CAAnB,CAAH;YACIE,kBAAkBrE,KAAAC,QAAA,CAAc,IAAAJ,MAAAS,OAAAC,KAAA+D,UAAA,EAAd;YAClBC,YAAY,QAAA,CAAgBF,eAAhB;;QAFhB;YAIIE;;QAJJ;QAMAC,UAAU,CAAAD,SAAA,EAAA,CAAYvE,KAAAC,QAAA,CAAc,IAAAC,MAAA,EAAd,CAAZ;QACVjB,YAAY,IAAAa,IAAA2E,KAAA,aAAsBD,oBAAiB,KAAvC;QAEZ,OAAO,IAAApE,OAAA,eAAsBnB,UAAtB;IAlBX;IAoBA;QAEJ;QAAA;;QACQyF,cAAcC,UAAA,CAAW,IAAAC,eAAA,EAAX,CAAAC,OAAA;QACd,OAAO9C,aAAA,CAAc2C,WAAd,QAAAI,OAAA;;IAJX;IAMA;QAIJ;QAAA;QAAA;QAAA;QACQ,IAAG,EAAA,CAAI,IAAA9F,UAAJ,CAAH;YACI,MAAM,IAAAe,UAAA,CAAW,YAAX;QADV;QAGA,OAAO,IAAAF,MAAAY,KAAAkB,QAAAoD,SAAAC,WAAAC,KAAA,gBACQ,CAAC,IAAA5F,aAAA,EAAD,EADR,CAAA,CAC+B,CAD/B;IARX;IAWA,gBAAwB,IAAxB,aAAuC,IAAvC,iBAA0D,IAA1D,oBAAgF,CAAhF;QAQJ;QAAA;QAAA;QAAA;QAAA;QAAA;QAAA;QAAA;;QACQ,IAAG6F,QAAH;YACIpC,oBAAoB,IAAAqC,SAAA;YACpB,IAAG,EAAA,CAAInC,eAAAC,WAAA,CAA2BH,iBAA3B,CAAJ,CAAH;gBACI,MAAMI,QAAAC,YAAA,CAAqBH,eAAAI,OAAA,CAAuBN,iBAAvB,CAArB;YADV;QAFJ;QAKAsC,WAAW,IAAAvF,MAAAwF,UAAAC,UAAAC,KAAA,eACG,IAAAX,eAAA,cAA8B,MADjC;QAGX,IAAGY,MAAH;YACI,OAAO,CACH,UADG,EACS,IAAA5G,SADT,EAEH,MAFG,EAEKwG,QAFL,QAAA,EAGD,IAAA/F,aAAA,EAHC;QADX;YAOI,wBAAeoG,eAAf,aAAA,QAAA;gBACI,IAAA5F,MAAA6F,gBAAA;gBACA;oBACIC,cAAc,IAAA9F,MAAA+F,QAAAC,mBAAA,CAAsCT,QAAtC;oBACd,IAAG,EAAA,CAAIpC,eAAAC,WAAA,CAA2B0C,WAA3B,CAAJ,CAAH;wBACI,MAAMzC,QAAAC,YAAA,CAAqBH,eAAAI,OAAA,CAAuBuC,WAAvB,CAArB;oBADV;+BAEA,CAAM,+BAAN;gBAJJ;sCAKOG;wBACH5G,MAAM,IAAAW,MAAA0C,aAAA,CAAkB,EAAA,CAAE,CAAAwD,CAAA,EAAA,CAAI,CAAJ,CAAF,CAAlB,CAAAC,eAAA,CAA4CZ,QAA5C;wBACN,IAAGa,YAAH;4BACI,IAAG,EAAA,CAAIjD,eAAAC,WAAA,CAA2B/D,GAA3B,CAAJ,CAAH;gCACI,MAAMgE,QAAAC,YAAA,CAAqBH,eAAAI,OAAA,CAAuBlE,GAAvB,CAArB;4BADV;wBADJ;wBAGA,OAAOA;;;;gBAVX;YAFJ;QAPJ;QAqBA,MAAM,IAAAgH,YAAA,CAAad,QAAb;IAtCV;IAwCA;QAIJ;QAAA;QAAA;QAAA;QACQ,OAAOpC,eAAAmD,qBAAA,CAAqC,IAAAhB,SAAA,EAArC;IALX;AAjPJ;;AAyPA", "sources": ["group.py"], "names": ["Interop", "this.contents", "contents", "this.protocol", "protocol", "this.chain_id", "chain_id", "this.branch", "branch", "this.signature", "signature", "res", "super.__repr__", "pformat", "this.json_payload", "get_class_docstring", "this.__class__", "\"\\n\".join", "OperationGroup", "kwargs", "kwargs.get", "this.contents.copy", "this.shell", "this.key", "ValueError", "bytes", "bytes.fromhex", "this.forge", "forge_base58", "this._spawn", "content", "this.shell.chains", "this.shell.chains.main", "this.shell.chains.main.chain_id", "this.shell.head", "this.shell.head.predecessor", "this.shell.head.predecessor.hash", "this.shell.head.header", "source", "this.key.public_key_hash", "counter", "this.shell.contracts", "this.shell.contracts[source].count", "replace_map", "content.copy", "replace_map.items", "content.get", "k", "v", "list", "map", "fill_content", "this.shell.head.helpers", "this.shell.head.helpers.scripts", "this.shell.head.helpers.scripts.run_operation", "this.shell.head.helpers.scripts.run_operation.post", "base58_encode", "base58_encode((b'0'\n * 64), b'sig'\n).decode", "payload", "local_data", "forge_operation_group", "forge_operation_group(payload).hex", "validate", "remote_data", "this.shell.blocks", "this.shell.blocks[this.branch].helpers", "this.shell.blocks[this.branch].helpers.forge", "this.shell.blocks[this.branch].helpers.forge.operations", "this.shell.blocks[this.branch].helpers.forge.operations.post", "opg", "this.fill", "opg_with_metadata", "opg.run", "OperationResult", "OperationResult.is_applied", "RpcError", "RpcError.from_errors", "OperationResult.errors", "extra_size", "validation_passes", "consumed_gas", "OperationResult.consumed_gas", "gas_reserve", "paid_storage_size_diff", "OperationResult.paid_storage_size_diff", "burned", "OperationResult.burned", "fee", "calculate_fee", "content.update", "content.pop", "opg.contents", "validation_pass", "any", "chain_watermark", "this.shell.chains.main.watermark", "watermark", "message", "this.key.sign", "hash_digest", "blake2b_32", "this.binary_payload", "blake2b_32(this.binary_payload()).digest", "base58_encode(hash_digest, b'o'\n).decode", "this.shell.head.helpers.preapply", "this.shell.head.helpers.preapply.operations", "this.shell.head.helpers.preapply.operations.post", "preapply", "this.preapply", "opg_hash", "this.shell.injection", "this.shell.injection.operation", "this.shell.injection.operation.post", "_async", "num_blocks_wait", "this.shell.wait_next_block", "pending_opg", "this.shell.mempool", "this.shell.mempool.pending_operations", "StopIteration", "i", "this.shell.blocks.slice((- (i + 1))).find_operation", "check_result", "TimeoutError", "OperationResult.from_operation_group"], "sourcesContent": ["from pprint import pformat\n\nfrom pytezos.crypto import blake2b_32\nfrom pytezos.operation.content import ContentMixin\nfrom pytezos.operation.forge import forge_operation_group\nfrom pytezos.operation.fees import calculate_fee, default_fee, default_gas_limit, default_storage_limit\nfrom pytezos.operation.result import OperationResult\nfrom pytezos.rpc.errors import RpcError\nfrom pytezos.encoding import forge_base58, base58_encode\nfrom pytezos.interop import Interop\nfrom pytezos.tools.docstring import get_class_docstring\n\nvalidation_passes = {\n    'endorsement': 0,\n    'proposal': 1,\n    'ballot': 1,\n    'seed_nonce_revelation': 2,\n    'double_endorsement_evidence': 2,\n    'double_baking_evidence': 2,\n    'activate_account': 2,\n    'reveal': 3,\n    'transaction': 3,\n    'origination': 3,\n    'delegation': 3\n}\n\n\nclass OperationGroup(Interop, ContentMixin):\n    \"\"\" Operation group representation: contents (single or multiple), signature, other fields,\n    and also useful helpers for filling with precise fees, signing, forging, and injecting.\n    \"\"\"\n\n    def __init__(self, contents=None, protocol=None, chain_id=None, branch=None, signature=None, shell=None, key=None):\n        JS(\"super(OperationGroup, self).__init__(shell=shell, key=key)\")\n        self.contents = contents or []\n        self.protocol = protocol\n        self.chain_id = chain_id\n        self.branch = branch\n        self.signature = signature\n\n    def __repr__(self):\n        res = [\n            super(OperationGroup, self).__repr__(),\n            '\\nPayload',\n            pformat(self.json_payload()),\n            '\\nHelpers',\n            get_class_docstring(self.__class__)\n        ]\n        return '\\n'.join(res)\n\n    def _spawn(self, **kwargs):\n        return OperationGroup(\n            contents=kwargs.get('contents', self.contents.copy()),\n            protocol=kwargs.get('protocol', self.protocol),\n            chain_id=kwargs.get('chain_id', self.chain_id),\n            branch=kwargs.get('branch', self.branch),\n            signature=kwargs.get('signature', self.signature),\n            shell=kwargs.get('shell', self.shell),\n            key=kwargs.get('key', self.key)\n        )\n\n    def json_payload(self) -> dict:\n        \"\"\" Get json payload used for the preapply.\n        \"\"\"\n        return {\n            'protocol': self.protocol,\n            'branch': self.branch,\n            'contents': self.contents,\n            'signature': self.signature\n        }\n\n    def binary_payload(self) -> bytes:\n        \"\"\" Get binary payload used for injection/hash calculation.\n        \"\"\"\n        if not self.signature:\n            raise ValueError('Not signed')\n\n        return bytes.fromhex(self.forge()) + forge_base58(self.signature)\n\n    def operation(self, content):\n        \"\"\" Create new operation group with extra content added.\n\n        :param content: Kind-specific operation body\n        :rtype: OperationGroup\n        \"\"\"\n        return self._spawn(contents=self.contents + [content])\n\n    def fill(self):\n        \"\"\" Try to fill all fields left unfilled, use approximate fees\n        (not optimal, use `autofill` to simulate operation and get precise values).\n\n        :rtype: OperationGroup\n        \"\"\"\n        chain_id = self.chain_id or self.shell.chains.main.chain_id()\n        branch = self.branch or self.shell.head.predecessor.hash()\n        protocol = self.protocol or self.shell.head.header()['protocol']\n        source = self.key.public_key_hash()\n        counter = self.shell.contracts[source].count()\n\n        replace_map = {\n            'pkh': source,\n            'source': source,\n            'delegate': source,  # self registration\n            'counter': lambda x: str(next(counter)),\n            'secret': lambda x: self.key.activation_code,\n            'period': lambda x: str(self.shell.head.voting_period()),\n            'public_key': lambda x: self.key.public_key(),\n            'manager_pubkey': source,  # I know, it hurts\n            'fee': lambda x: str(default_fee(x)),\n            'gas_limit': lambda x: str(default_gas_limit(x)),\n            'storage_limit': lambda x: str(default_storage_limit(x)),\n        }\n\n        def fill_content(content):\n            content = content.copy()\n            for k, v in replace_map.items():\n                if content.get(k) in ['', '0']:\n                    content[k] = v(content) if callable(v) else v\n            return content\n\n        return self._spawn(\n            contents=list(map(fill_content, self.contents)),\n            protocol=protocol,\n            chain_id=chain_id,\n            branch=branch\n        )\n\n    def run(self):\n        \"\"\" Simulate operation without signature checks.\n\n        :returns: RPC response from `run_operation`\n        \"\"\"\n        return self.shell.head.helpers.scripts.run_operation.post({\n            'operation': {\n                'branch': self.branch,\n                'contents': self.contents,\n                'signature': base58_encode(JS(\"b'0'\") * 64, JS(\"b'sig'\")).decode()\n            },\n            'chain_id': self.chain_id\n        })\n\n    def forge(self, validate=True):\n        \"\"\" Convert json representation of the operation group into bytes.\n\n        :param validate: Forge remotely also and compare results, default is True\n        :returns: Hex string\n        \"\"\"\n        payload = {\n            'branch': self.branch,\n            'contents': self.contents\n        }\n        local_data = forge_operation_group(payload).hex()\n\n        if validate:\n            remote_data = self.shell.blocks[self.branch].helpers.forge.operations.post(payload)\n            if local_data != remote_data:\n                raise ValueError(f'Local forge result differs from remote one:\\n\\n{local_data}\\n\\n{remote_data}')\n\n        return local_data\n\n    def autofill(self, gas_reserve=100):\n        \"\"\" Fill the gaps and then simulate the operation in order to calculate fee, gas/storage limits.\n\n        :param gas_reserve: Add a safe reserve for gas limit (default is 100)\n        :rtype: OperationGroup\n        \"\"\"\n        opg = self.fill()\n        opg_with_metadata = opg.run()\n        if not OperationResult.is_applied(opg_with_metadata):\n            raise RpcError.from_errors(OperationResult.errors(opg_with_metadata)) from None\n\n        extra_size = JS(\"(32 + 64) // len(opg.contents) + 1\")  # size of serialized branch and signature)\n\n        def fill_content(content):\n            if validation_passes[content['kind']] == 3:\n                consumed_gas = OperationResult.consumed_gas(content) + gas_reserve\n                paid_storage_size_diff = OperationResult.paid_storage_size_diff(content)\n                burned = OperationResult.burned(content)\n                fee = calculate_fee(content, consumed_gas, extra_size)\n                content.update(\n                    gas_limit=str(consumed_gas + gas_reserve),\n                    storage_limit=str(paid_storage_size_diff + burned),\n                    fee=str(fee)\n                )\n\n            content.pop('metadata')\n            return content\n\n        opg.contents = list(map(fill_content, opg_with_metadata['contents']))\n        return opg\n\n    def sign(self):\n        \"\"\" Sign the operation group with the key specified by `using`.\n\n        :rtype: OperationGroup\n        \"\"\"\n        validation_pass = validation_passes[self.contents[0]['kind']]\n        if any(map(lambda x: validation_passes[x['kind']] != validation_pass, self.contents)):\n            raise ValueError('Mixed validation passes')\n\n        if validation_pass == 0:\n            chain_watermark = bytes.fromhex(self.shell.chains.main.watermark())\n            watermark = JS(\"b'\\x02'\") + chain_watermark\n        else:\n            watermark = JS(\"b'\\x03'\")\n\n        message = watermark + bytes.fromhex(self.forge())\n        signature = self.key.sign(message=message, generic=True)\n\n        return self._spawn(signature=signature)\n\n    def hash(self) -> str:\n        \"\"\" Calculate the Base58 encoded operation group hash.\n        \"\"\"\n        hash_digest = blake2b_32(self.binary_payload()).digest()\n        return base58_encode(hash_digest, JS(\"b'o'\")).decode()\n\n    def preapply(self):\n        \"\"\" Preapply signed operation group.\n\n        :returns: RPC response from `preapply`\n        \"\"\"\n        if not self.signature:\n            raise ValueError('Not signed')\n\n        return self.shell.head.helpers.preapply.operations.post(\n            operations=[self.json_payload()])[0]\n\n    def inject(self, _async=True, preapply=True, check_result=True, num_blocks_wait=2):\n        \"\"\" Inject the signed operation group.\n\n        :param _async: do not wait for operation inclusion (default is True)\n        :param preapply: do a preapply before injection\n        :param check_result: raise RpcError in case operation is refused\n        :param num_blocks_wait: number of blocks to wait for injection\n        :returns: operation group with metadata (raw RPC response)\n        \"\"\"\n        if preapply:\n            opg_with_metadata = self.preapply()\n            if not OperationResult.is_applied(opg_with_metadata):\n                raise RpcError.from_errors(OperationResult.errors(opg_with_metadata)) from None\n\n        opg_hash = self.shell.injection.operation.post(\n            operation=self.binary_payload(), _async=False)\n\n        if _async:\n            return {\n                'chain_id': self.chain_id,\n                'hash': opg_hash,\n                **self.json_payload()\n            }\n        else:\n            for i in range(num_blocks_wait):\n                self.shell.wait_next_block()\n                try:\n                    pending_opg = self.shell.mempool.pending_operations[opg_hash]\n                    if not OperationResult.is_applied(pending_opg):\n                        raise RpcError.from_errors(OperationResult.errors(pending_opg)) from None\n                    print(f'Still in mempool: {opg_hash}')\n                except StopIteration:\n                    res = self.shell.blocks[-(i + 1):].find_operation(opg_hash)\n                    if check_result:\n                        if not OperationResult.is_applied(res):\n                            raise RpcError.from_errors(OperationResult.errors(res)) from None\n                    return res\n\n        raise TimeoutError(opg_hash)\n\n    def result(self):\n        \"\"\" Parse the preapply result.\n\n        :rtype: OperationResult\n        \"\"\"\n        return OperationResult.from_operation_group(self.preapply())\n\n\n__all__ = [\"OperationGroup\", \"validation_passes\"]\n"]}